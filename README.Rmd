---
output:
  rmarkdown::github_document:
    html_preview: no
---

```{r, include = FALSE}
knitr::opts_chunk$set(fig.path = "man/figures/README-", fig.align = "center",
                      fig.height = 4.5, fig.width = 4.5)
```

<!--- README.md is generated from README.Rmd. Please edit that file -->

## restopr: Ecological Restoration Planning

[![lifecycle](https://img.shields.io/badge/Lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html)
[![R-CMD-check-Ubuntu](https://img.shields.io/github/workflow/status/dimitri-justeau/restoptr/Ubuntu/master.svg?label=Ubuntu)](https://github.com/dimitri-justeau/restoptr/actions)
[![R-CMD-check-Windows](https://img.shields.io/github/workflow/status/dimitri-justeau/restoptr/Windows/master.svg?label=Windows)](https://github.com/dimitri-justeau/restoptr/actions)
[![R-CMD-check-MacOS](https://img.shields.io/github/workflow/status/dimitri-justeau/restoptr/macOS/master.svg?label=macOS)](https://github.com/dimitri-justeau/restoptr/actions)
[![Coverage Status](https://codecov.io/github/dimitri-justeau/restoptr/coverage.svg?branch=master)](https://app.codecov.io/gh/dimitri-justeau/restoptr)
[![CRAN_Status_Badge](http://www.r-pkg.org/badges/version/restoptr)](https://github.com/dimitri-justeau/restoptr)

```{r, include = FALSE}
devtools::load_all()
```

  * [Overview](#overview)
  * [Installation](#installation)
    * [Optional - Building `restopt` (Java core library) from source](#java_sources)
    * [Package installation](#package_install)
    * [System dependencies](#system_deps)
  * [Citation](#citation)
  * [Usage](#usage)
  * [Getting help](#help)
  * [References](#ref)

## Overview <a name="overview"></a>

The `restoptr` R package is a flexible ecological restoration planning
framework with many ideas inspired from the [`prioritizr`](https://prioritizr.net/)
conservation planning package (Hanson et al., 2022). In `restoptr`, a restoration
planning problem starts from an existing habitat (typically a binary raster), where
the aim is to identify optimal areas that are suitable for restoration. Several
constraints are available to define what is expected for a suitable area for (e.g.
it must be connected, compact, must respect a budget, etc). Several optimization
objective are also available to define what is a good restoration area (e.g. it 
must reduce fragmentation, increase ecological connectivity, minimize costs, etc.).
`restoptr` relies on advanced landscape indices such as the effective mesh size
(Jaeger, 2000), or the integral index of connectivity (Pascual-Hortal & Saura, 2006)
to address complex restoration planning problems.

`restoptr` extends the methodology originally described in [this article](https://www.researchgate.net/publication/346597935_Constrained_optimization_of_landscape_indices_in_conservation_planning_to_support_ecological_restoration_in_New_Caledonia),
and is based on Constraint Programming (CP), which is a constrained optimization solving technique based on automated reasoning. Specifically, `restoptr` relies on
[Choco-solver](https://choco-solver.org/), an open-source Java CP solver 
(Prud'homme et al., 2017). The computationally intensive solving part is thus
delegated to Java (see `restopt`, https://github.com/dimitri-justeau/restopt), 
and the communication between R and Java is handled with the [`rJava`]()
package.

**Note:** If you feel like something is missing from `restoptr` (e.g. landscape
indices, constraints, optimization objectives), feel free to [open an issue](#help)
and/or contribute. The framework was designed to be extensible and we will be
happy to integrate new features to our roadmap if they are motivated by users' needs.

## Installation <a name="installation"></a>

### Optional - Building `restopt` (Java core library) from source <a name="java_sources"></a>

`restoptr` relies on a core Java library called [`restopt`](https://github.com/dimitri-justeau/restopt), which handle the constrained optimization process with [Choco-solver](https://choco-solver.org/). We included a compiled `restopt` jar file in `restoptr` to spare users from compiling the Java source code themselves.

However, if you want to compile `restopt` Java source code and use it in `restoptr`, you need a Java Development Kit (JDK) version 8 or higher (see [Oracle JDK](https://www.oracle.com/java/technologies/javase-downloads.html), [OpenJDK](https://openjdk.java.net/install/), or [GraalVM](https://www.graalvm.org/downloads/)). You also need to install [Maven](https://maven.apache.org/).

Once these dependencies are installed, from the `restoptr` folder execute the following command lines from a terminal to build `restopt`:

First clone the repository and update the source code:

```{bash, eval = FALSE}
git clone https://github.com/dimitri-justeau/restoptr.git
cd restoptr
git submodule update --init --recursive
```

Then build the Java source code with Maven:

```{bash, eval = FALSE}
cd restopt
mvn clean package -DskipTests
```

Finally, copy the generated jar file into `restoptr` java directory:

```{bash, eval = FALSE}
cp target/restopt-*.jar ../java/
```

To update `restopt` and `restoptr` with the latest source code, execute the
following command (from the restoptr folder):

```{bash, eval = FALSE}
git pull --recurse-submodules
```

### Package installation <a name="package_install"></a>

The latest developmental version of the _restoptr R_ package can be installed using the following _R_ code.

```{r, eval = FALSE}
if (!require(remotes)) install.packages("remotes")
remotes::install_github("dimitri-justeau/restoptr")
```

Or with _devtools_:

```{r, eval = FALSE}
if (!require(devtools)) install.packages("devtools")
devtools::install_github("dimitri-justeau/rflsgen")
```

### System dependencies <a name="system_deps"></a>

The packages requires a Java Runtime Environment (JRE), version 8 or higher. Below we provide platform-specific instructions to install it.

#### _Windows_

Please install the latest Java Runtime Environment from [Oracle](www.oracle.com) website. To achieve this, navigate to the [downloads section of the website](https://www.oracle.com/java/technologies/javase-downloads.html), select the tab for the Windows operating system, and then download the x64 Installer file. After downloading the file, please run installer to install Java on your system. You will also need to ensure that the `PATH` environmental variable if configured so that _R_ can access Java. _restoptr_ relies on _rJava_ for the communication between _R_ and _Java_. If you have any trouble during the installation of _restopt_ due to _rJava_, please refer to _rJava_'s documentation: https://rforge.net/rJava/index.html.

#### _Ubuntu_

For recent versions of Ubuntu (18.04 and later), the Java libraries are available through official repositories. They can be installed using the following system commands.

```{bash, eval = FALSE}
sudo apt-get install default-jdk
```

If you want to install a specific JRE version, please follow instructions from [Oracle](https://www.oracle.com/java/technologies/javase-downloads.html), [OpenJDK](https://openjdk.java.net/install/), or [GraalVM](https://www.graalvm.org/downloads/).

#### _Linux_

Please follow instructions from [Oracle](https://www.oracle.com/java/technologies/javase-downloads.html), [OpenJDK](https://openjdk.java.net/install/), or [GraalVM](https://www.graalvm.org/downloads/).

#### _MacOS_

The easiest way to install the Java libraries is using [HomeBrew](https://brew.sh/). After installing HomeBrew, the Java libraries can be installed using the following system commands.

```{bash, eval = FALSE}
brew install openjdk
```

Please note that you might also need to ensure that the `PATH` environmental variable if configured so that _R_ can access Java.

## Citation <a name="citation"></a>

Please cite _restoptr_ when using it in publications.

> Justeau-Allaire, D., Vieilledent, G., Rinck, N., Vismara, P., Lorca, X., & Birnbaum, P. (2021). Constrained optimization of landscape indices in conservation planning to support ecological restoration in New Caledonia. Journal of Applied Ecology, 58(4), 744â€‘754.

This article describes the methodology. We will provide a specific citation for ressource the R package soon.

## Usage <a name="usage"></a>

The first thing to do to use _restoptr_ is to load the package:

```{r}
library(restoptr)
```

We will now create and solve a restoration optimization problem. One input
raster are necessary, the *existing_habitat* raster, which is a binary raster
indicating the habitat areas (raster value 1), the non-habitat areas (raster
value 0), and areas that are not part of the landscape (raster value NA, or
NODATA, e.g. ocean if the landscape is terrestrial). Note that the resolution
can be high, as the down sampling of the input data to ensure a tractable
optimization problem is part of the restoration optimization problem 
construction (see the next paragraph).
  
Along with this *existing_habitat* input raster, it is necessary to provide
two parameters that inform `restoptr` how to eventually reduce the resolution
to ensure a tractable optimization problem: the *aggregation_factor* and the
*habitat_threshold* :

- *aggregation_factor*: if the resolution of the *existing_habitat* is high, it
  can be unsuited to use as is into the constrained optimization engine, which
  will either be limited by the system's available RAM, or have a very long
  computation time. The *aggregation_factor* indicates how to reduce the resolution
  of the aggregating cells (see `terra::aggregate()`). The amount of habitat and
  restorable area within each aggregated cell will be automatically computed.
  
- *habitat_threshold*: as the lower resolution habitat raster that will be used
  into the constrained optimization engine must be binary, it is necessary to
  define a condition which indicates whether an aggregated is considered as
  habitat or not. This condition is defined by the *habitat_threshold*, which
  indicates how much proportion of habitat is needed into an aggregated cell
  to consider it as habitat.

**Note:** In the following, we will also refer to the aggregated cells as
**planning units**.

**Note:** we implemented this data pre processing step as a new feature in
`restoptr` to facilitate its usage, to ensure that problems are instantiated with
consistent information, and to facilitate the automation of workflows. For more
details on the aggregation method, please refer to `prepare_inputs()` function
documentation.

Example data, from the use case presented in [this study](https://www.researchgate.net/publication/346597935_Constrained_optimization_of_landscape_indices_in_conservation_planning_to_support_ecological_restoration_in_New_Caledonia)
is included in the package:

```{r, out.width="100%", fig.width = 10}
habitat_data <- rast(
  system.file("extdata", "habitat_hi_res.tif", package = "restoptr")
)
plot(habitat_data, plg=list(x="topright"))
```

To instantiate a base restoration optimization problem from such an input raster,
use the `restopt_problem()` function:

```{r}
p <- restopt_problem(
  existing_habitat = habitat_data, 
  aggregation_factor = 16,
  habitat_threshold = 0.7
) 
```

Input data and preprocessed aggregated rasters can be accessed with:

- `get_original_habiata(p)` is the input, high resolution habitat raster.
- `get_existing_habitat(p)` is the aggregated habitat raster.
- `get_restorable_habitat(p)` is the aggregated restorable area raster.
- `get_cell_area(p)` is the area of each planning, in number of cells
  from the original raster. Note that this area is not necessarily the same
  for all planning units, as if there are NA cells in the input raster some
  planning units can partially cover NA and non-NA cells.

We can plot the aggregated data:

```{r, out.width="100%", fig.width = 10}
plot(rast(list(p$data$existing_habitat, p$data$restorable_habitat)), nc = 2,  plg=list(x="topright"))
```

Then, we can add constraints to this base problem. For instance, lets add a
locked-out constraint, to restrict the number of planning units that can be
selected for restoration. Such a constraint can be used to account for existing
land-use practices, feasibility of restoration activities, and stakeholder 
preferences.

```{r}
locked_out_data <- rast(
 system.file("extdata", "locked_out.tif", package = "restoptr")
)
p <- p %>% add_locked_out_constraint(data = locked_out_data)
```

We can also add a constraint on the amount of restored area that is allowed by the
project:

```{r}
p <- p %>% add_restorable_constraint(90, 220, unit = "ha")
```

And finally a compactness constraint, which limits the spatial extent of the
selected restoration area:

```{r}
p <- p %>% add_compactness_constraint(2.4, unit = "km")
```

**Note:** units conversions are handled by the [units](https://r-quantities.github.io/units/)
package, thus feel free to use any surface or length unit when defining your constraints.

Once we have added constraints to the problem, we need to define an optimization
objective. For example, lets configure `restopr` to identify, under the previous
constraints, which restoration areas maximizes the effective mesh size (MESH).

```{r}
p <- p %>% set_max_mesh_objective()
```

*Note* The effective mesh size is a measure of landscape fragmentation based on
the probability that two randomly chosen points are located in the same patch
[Jaeger, 2000](https://doi.org/10.1023/A:1008129329289). Maximizing it in the
context of restoration favours fewer and larger patches.

We can get a summary of the restoration problem:

```{r}
p
```

Finally, we use the `solve()` function to identify the optimal restoration area,
according to the constraints and the optimization objective.

```{r, out.width="100%", fig.width = 10}
s <- solve(p)
plot(
  s,
  main = "Solution",
  col = c("#E5E5E5", "#fff1d6", "#b2df8a", "#1f78b4"),
  plg = list(x="topright")
)
```

You can retrieve the attributes of the solution using the `get_metadata()` function:

```{r}
get_metadata(s, area_unit = "ha")
```

## Getting help <a name="help"></a>

If you have any questions about _restoptr_, improvement suggestions, or if you detect a bug, please [open an issue](https://github.com/dimitri-justeau/restoptr/issues/new/choose) in this GitHub repository.

## References <a name="ref"></a>

Hanson JO, Schuster R, Morrell N, Strimas-Mackey M, Edwards BPM, Watts ME,
Arcese P, Bennett J, Possingham HP (2022). prioritizr: Systematic Conservation
Prioritization in R. R package version 7.1.1. Available at
https://CRAN.R-project.org/package=prioritizr.

Jaeger, J. A. G. (2000). Landscape division, splitting index, and effective
mesh size: New measures of landscape fragmentation. Landscape Ecology, 15(2),
115â€‘130. https://doi.org/10.1023/A:1008129329289

Justeau-Allaire, D., Vieilledent, G., Rinck, N., Vismara, P., Lorca, X.,
& Birnbaum, P. (2021). Constrained optimization of landscape indices in
conservation planning to support ecological restoration in New Caledonia.
Journal of Applied Ecology, 58(4), 744â€‘754.

Pascual-Hortal, L., & Saura, S. (2006).
Comparison and development of new graph-based landscape connectivity indices:
Towards the priorization of habitat patches and corridors for conservation.
Landscape Ecology, 21(7), 959â€‘967. https://doi.org/10.1007/s10980-006-0013-z

Prud'homme, C., Fages, J.-G., & Lorca, X. (2017). Choco documentation.
