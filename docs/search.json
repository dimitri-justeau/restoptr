[{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"GNU General Public License","title":"GNU General Public License","text":"Version 3, 29 June 2007Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/> Everyone permitted copy distribute verbatim copies license document, changing allowed.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"preamble","dir":"","previous_headings":"","what":"Preamble","title":"GNU General Public License","text":"GNU General Public License free, copyleft license software kinds works. licenses software practical works designed take away freedom share change works. contrast, GNU General Public License intended guarantee freedom share change versions program–make sure remains free software users. , Free Software Foundation, use GNU General Public License software; applies also work released way authors. can apply programs, . speak free software, referring freedom, price. General Public Licenses designed make sure freedom distribute copies free software (charge wish), receive source code can get want , can change software use pieces new free programs, know can things. protect rights, need prevent others denying rights asking surrender rights. Therefore, certain responsibilities distribute copies software, modify : responsibilities respect freedom others. example, distribute copies program, whether gratis fee, must pass recipients freedoms received. must make sure , , receive can get source code. must show terms know rights. Developers use GNU GPL protect rights two steps: (1) assert copyright software, (2) offer License giving legal permission copy, distribute /modify . developers’ authors’ protection, GPL clearly explains warranty free software. users’ authors’ sake, GPL requires modified versions marked changed, problems attributed erroneously authors previous versions. devices designed deny users access install run modified versions software inside , although manufacturer can . fundamentally incompatible aim protecting users’ freedom change software. systematic pattern abuse occurs area products individuals use, precisely unacceptable. Therefore, designed version GPL prohibit practice products. problems arise substantially domains, stand ready extend provision domains future versions GPL, needed protect freedom users. Finally, every program threatened constantly software patents. States allow patents restrict development use software general-purpose computers, , wish avoid special danger patents applied free program make effectively proprietary. prevent , GPL assures patents used render program non-free. precise terms conditions copying, distribution modification follow.","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_0-definitions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"0. Definitions","title":"GNU General Public License","text":"“License” refers version 3 GNU General Public License. “Copyright” also means copyright-like laws apply kinds works, semiconductor masks. “Program” refers copyrightable work licensed License. licensee addressed “”. “Licensees” “recipients” may individuals organizations. “modify” work means copy adapt part work fashion requiring copyright permission, making exact copy. resulting work called “modified version” earlier work work “based ” earlier work. “covered work” means either unmodified Program work based Program. “propagate” work means anything , without permission, make directly secondarily liable infringement applicable copyright law, except executing computer modifying private copy. Propagation includes copying, distribution (without modification), making available public, countries activities well. “convey” work means kind propagation enables parties make receive copies. Mere interaction user computer network, transfer copy, conveying. interactive user interface displays “Appropriate Legal Notices” extent includes convenient prominently visible feature (1) displays appropriate copyright notice, (2) tells user warranty work (except extent warranties provided), licensees may convey work License, view copy License. interface presents list user commands options, menu, prominent item list meets criterion.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_1-source-code","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"1. Source Code","title":"GNU General Public License","text":"“source code” work means preferred form work making modifications . “Object code” means non-source form work. “Standard Interface” means interface either official standard defined recognized standards body, , case interfaces specified particular programming language, one widely used among developers working language. “System Libraries” executable work include anything, work whole, () included normal form packaging Major Component, part Major Component, (b) serves enable use work Major Component, implement Standard Interface implementation available public source code form. “Major Component”, context, means major essential component (kernel, window system, ) specific operating system () executable work runs, compiler used produce work, object code interpreter used run . “Corresponding Source” work object code form means source code needed generate, install, (executable work) run object code modify work, including scripts control activities. However, include work’s System Libraries, general-purpose tools generally available free programs used unmodified performing activities part work. example, Corresponding Source includes interface definition files associated source files work, source code shared libraries dynamically linked subprograms work specifically designed require, intimate data communication control flow subprograms parts work. Corresponding Source need include anything users can regenerate automatically parts Corresponding Source. Corresponding Source work source code form work.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_2-basic-permissions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"2. Basic Permissions","title":"GNU General Public License","text":"rights granted License granted term copyright Program, irrevocable provided stated conditions met. License explicitly affirms unlimited permission run unmodified Program. output running covered work covered License output, given content, constitutes covered work. License acknowledges rights fair use equivalent, provided copyright law. may make, run propagate covered works convey, without conditions long license otherwise remains force. may convey covered works others sole purpose make modifications exclusively , provide facilities running works, provided comply terms License conveying material control copyright. thus making running covered works must exclusively behalf, direction control, terms prohibit making copies copyrighted material outside relationship . Conveying circumstances permitted solely conditions stated . Sublicensing allowed; section 10 makes unnecessary.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_3-protecting-users-legal-rights-from-anti-circumvention-law","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"3. Protecting Users’ Legal Rights From Anti-Circumvention Law","title":"GNU General Public License","text":"covered work shall deemed part effective technological measure applicable law fulfilling obligations article 11 WIPO copyright treaty adopted 20 December 1996, similar laws prohibiting restricting circumvention measures. convey covered work, waive legal power forbid circumvention technological measures extent circumvention effected exercising rights License respect covered work, disclaim intention limit operation modification work means enforcing, work’s users, third parties’ legal rights forbid circumvention technological measures.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_4-conveying-verbatim-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"4. Conveying Verbatim Copies","title":"GNU General Public License","text":"may convey verbatim copies Program’s source code receive , medium, provided conspicuously appropriately publish copy appropriate copyright notice; keep intact notices stating License non-permissive terms added accord section 7 apply code; keep intact notices absence warranty; give recipients copy License along Program. may charge price price copy convey, may offer support warranty protection fee.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_5-conveying-modified-source-versions","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"5. Conveying Modified Source Versions","title":"GNU General Public License","text":"may convey work based Program, modifications produce Program, form source code terms section 4, provided also meet conditions: ) work must carry prominent notices stating modified , giving relevant date. b) work must carry prominent notices stating released License conditions added section 7. requirement modifies requirement section 4 “keep intact notices”. c) must license entire work, whole, License anyone comes possession copy. License therefore apply, along applicable section 7 additional terms, whole work, parts, regardless packaged. License gives permission license work way, invalidate permission separately received . d) work interactive user interfaces, must display Appropriate Legal Notices; however, Program interactive interfaces display Appropriate Legal Notices, work need make . compilation covered work separate independent works, nature extensions covered work, combined form larger program, volume storage distribution medium, called “aggregate” compilation resulting copyright used limit access legal rights compilation’s users beyond individual works permit. Inclusion covered work aggregate cause License apply parts aggregate.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_6-conveying-non-source-forms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"6. Conveying Non-Source Forms","title":"GNU General Public License","text":"may convey covered work object code form terms sections 4 5, provided also convey machine-readable Corresponding Source terms License, one ways: ) Convey object code , embodied , physical product (including physical distribution medium), accompanied Corresponding Source fixed durable physical medium customarily used software interchange. b) Convey object code , embodied , physical product (including physical distribution medium), accompanied written offer, valid least three years valid long offer spare parts customer support product model, give anyone possesses object code either (1) copy Corresponding Source software product covered License, durable physical medium customarily used software interchange, price reasonable cost physically performing conveying source, (2) access copy Corresponding Source network server charge. c) Convey individual copies object code copy written offer provide Corresponding Source. alternative allowed occasionally noncommercially, received object code offer, accord subsection 6b. d) Convey object code offering access designated place (gratis charge), offer equivalent access Corresponding Source way place charge. need require recipients copy Corresponding Source along object code. place copy object code network server, Corresponding Source may different server (operated third party) supports equivalent copying facilities, provided maintain clear directions next object code saying find Corresponding Source. Regardless server hosts Corresponding Source, remain obligated ensure available long needed satisfy requirements. e) Convey object code using peer--peer transmission, provided inform peers object code Corresponding Source work offered general public charge subsection 6d. separable portion object code, whose source code excluded Corresponding Source System Library, need included conveying object code work. “User Product” either (1) “consumer product”, means tangible personal property normally used personal, family, household purposes, (2) anything designed sold incorporation dwelling. determining whether product consumer product, doubtful cases shall resolved favor coverage. particular product received particular user, “normally used” refers typical common use class product, regardless status particular user way particular user actually uses, expects expected use, product. product consumer product regardless whether product substantial commercial, industrial non-consumer uses, unless uses represent significant mode use product. “Installation Information” User Product means methods, procedures, authorization keys, information required install execute modified versions covered work User Product modified version Corresponding Source. information must suffice ensure continued functioning modified object code case prevented interfered solely modification made. convey object code work section , , specifically use , User Product, conveying occurs part transaction right possession use User Product transferred recipient perpetuity fixed term (regardless transaction characterized), Corresponding Source conveyed section must accompanied Installation Information. requirement apply neither third party retains ability install modified object code User Product (example, work installed ROM). requirement provide Installation Information include requirement continue provide support service, warranty, updates work modified installed recipient, User Product modified installed. Access network may denied modification materially adversely affects operation network violates rules protocols communication across network. Corresponding Source conveyed, Installation Information provided, accord section must format publicly documented (implementation available public source code form), must require special password key unpacking, reading copying.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_7-additional-terms","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"7. Additional Terms","title":"GNU General Public License","text":"“Additional permissions” terms supplement terms License making exceptions one conditions. Additional permissions applicable entire Program shall treated though included License, extent valid applicable law. additional permissions apply part Program, part may used separately permissions, entire Program remains governed License without regard additional permissions. convey copy covered work, may option remove additional permissions copy, part . (Additional permissions may written require removal certain cases modify work.) may place additional permissions material, added covered work, can give appropriate copyright permission. Notwithstanding provision License, material add covered work, may (authorized copyright holders material) supplement terms License terms: ) Disclaiming warranty limiting liability differently terms sections 15 16 License; b) Requiring preservation specified reasonable legal notices author attributions material Appropriate Legal Notices displayed works containing ; c) Prohibiting misrepresentation origin material, requiring modified versions material marked reasonable ways different original version; d) Limiting use publicity purposes names licensors authors material; e) Declining grant rights trademark law use trade names, trademarks, service marks; f) Requiring indemnification licensors authors material anyone conveys material (modified versions ) contractual assumptions liability recipient, liability contractual assumptions directly impose licensors authors. non-permissive additional terms considered “restrictions” within meaning section 10. Program received , part , contains notice stating governed License along term restriction, may remove term. license document contains restriction permits relicensing conveying License, may add covered work material governed terms license document, provided restriction survive relicensing conveying. add terms covered work accord section, must place, relevant source files, statement additional terms apply files, notice indicating find applicable terms. Additional terms, permissive non-permissive, may stated form separately written license, stated exceptions; requirements apply either way.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_8-termination","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"8. Termination","title":"GNU General Public License","text":"may propagate modify covered work except expressly provided License. attempt otherwise propagate modify void, automatically terminate rights License (including patent licenses granted third paragraph section 11). However, cease violation License, license particular copyright holder reinstated () provisionally, unless copyright holder explicitly finally terminates license, (b) permanently, copyright holder fails notify violation reasonable means prior 60 days cessation. Moreover, license particular copyright holder reinstated permanently copyright holder notifies violation reasonable means, first time received notice violation License (work) copyright holder, cure violation prior 30 days receipt notice. Termination rights section terminate licenses parties received copies rights License. rights terminated permanently reinstated, qualify receive new licenses material section 10.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_9-acceptance-not-required-for-having-copies","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"9. Acceptance Not Required for Having Copies","title":"GNU General Public License","text":"required accept License order receive run copy Program. Ancillary propagation covered work occurring solely consequence using peer--peer transmission receive copy likewise require acceptance. However, nothing License grants permission propagate modify covered work. actions infringe copyright accept License. Therefore, modifying propagating covered work, indicate acceptance License .","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_10-automatic-licensing-of-downstream-recipients","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"10. Automatic Licensing of Downstream Recipients","title":"GNU General Public License","text":"time convey covered work, recipient automatically receives license original licensors, run, modify propagate work, subject License. responsible enforcing compliance third parties License. “entity transaction” transaction transferring control organization, substantially assets one, subdividing organization, merging organizations. propagation covered work results entity transaction, party transaction receives copy work also receives whatever licenses work party’s predecessor interest give previous paragraph, plus right possession Corresponding Source work predecessor interest, predecessor can get reasonable efforts. may impose restrictions exercise rights granted affirmed License. example, may impose license fee, royalty, charge exercise rights granted License, may initiate litigation (including cross-claim counterclaim lawsuit) alleging patent claim infringed making, using, selling, offering sale, importing Program portion .","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_11-patents","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"11. Patents","title":"GNU General Public License","text":"“contributor” copyright holder authorizes use License Program work Program based. work thus licensed called contributor’s “contributor version”. contributor’s “essential patent claims” patent claims owned controlled contributor, whether already acquired hereafter acquired, infringed manner, permitted License, making, using, selling contributor version, include claims infringed consequence modification contributor version. purposes definition, “control” includes right grant patent sublicenses manner consistent requirements License. contributor grants non-exclusive, worldwide, royalty-free patent license contributor’s essential patent claims, make, use, sell, offer sale, import otherwise run, modify propagate contents contributor version. following three paragraphs, “patent license” express agreement commitment, however denominated, enforce patent (express permission practice patent covenant sue patent infringement). “grant” patent license party means make agreement commitment enforce patent party. convey covered work, knowingly relying patent license, Corresponding Source work available anyone copy, free charge terms License, publicly available network server readily accessible means, must either (1) cause Corresponding Source available, (2) arrange deprive benefit patent license particular work, (3) arrange, manner consistent requirements License, extend patent license downstream recipients. “Knowingly relying” means actual knowledge , patent license, conveying covered work country, recipient’s use covered work country, infringe one identifiable patents country reason believe valid. , pursuant connection single transaction arrangement, convey, propagate procuring conveyance , covered work, grant patent license parties receiving covered work authorizing use, propagate, modify convey specific copy covered work, patent license grant automatically extended recipients covered work works based . patent license “discriminatory” include within scope coverage, prohibits exercise , conditioned non-exercise one rights specifically granted License. may convey covered work party arrangement third party business distributing software, make payment third party based extent activity conveying work, third party grants, parties receive covered work , discriminatory patent license () connection copies covered work conveyed (copies made copies), (b) primarily connection specific products compilations contain covered work, unless entered arrangement, patent license granted, prior 28 March 2007. Nothing License shall construed excluding limiting implied license defenses infringement may otherwise available applicable patent law.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_12-no-surrender-of-others-freedom","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"12. No Surrender of Others’ Freedom","title":"GNU General Public License","text":"conditions imposed (whether court order, agreement otherwise) contradict conditions License, excuse conditions License. convey covered work satisfy simultaneously obligations License pertinent obligations, consequence may convey . example, agree terms obligate collect royalty conveying convey Program, way satisfy terms License refrain entirely conveying Program.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_13-use-with-the-gnu-affero-general-public-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"13. Use with the GNU Affero General Public License","title":"GNU General Public License","text":"Notwithstanding provision License, permission link combine covered work work licensed version 3 GNU Affero General Public License single combined work, convey resulting work. terms License continue apply part covered work, special requirements GNU Affero General Public License, section 13, concerning interaction network apply combination .","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_14-revised-versions-of-this-license","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"14. Revised Versions of this License","title":"GNU General Public License","text":"Free Software Foundation may publish revised /new versions GNU General Public License time time. new versions similar spirit present version, may differ detail address new problems concerns. version given distinguishing version number. Program specifies certain numbered version GNU General Public License “later version” applies , option following terms conditions either numbered version later version published Free Software Foundation. Program specify version number GNU General Public License, may choose version ever published Free Software Foundation. Program specifies proxy can decide future versions GNU General Public License can used, proxy’s public statement acceptance version permanently authorizes choose version Program. Later license versions may give additional different permissions. However, additional obligations imposed author copyright holder result choosing follow later version.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_15-disclaimer-of-warranty","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"15. Disclaimer of Warranty","title":"GNU General Public License","text":"WARRANTY PROGRAM, EXTENT PERMITTED APPLICABLE LAW. EXCEPT OTHERWISE STATED WRITING COPYRIGHT HOLDERS /PARTIES PROVIDE PROGRAM “” WITHOUT WARRANTY KIND, EITHER EXPRESSED IMPLIED, INCLUDING, LIMITED , IMPLIED WARRANTIES MERCHANTABILITY FITNESS PARTICULAR PURPOSE. ENTIRE RISK QUALITY PERFORMANCE PROGRAM . PROGRAM PROVE DEFECTIVE, ASSUME COST NECESSARY SERVICING, REPAIR CORRECTION.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_16-limitation-of-liability","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"16. Limitation of Liability","title":"GNU General Public License","text":"EVENT UNLESS REQUIRED APPLICABLE LAW AGREED WRITING COPYRIGHT HOLDER, PARTY MODIFIES /CONVEYS PROGRAM PERMITTED , LIABLE DAMAGES, INCLUDING GENERAL, SPECIAL, INCIDENTAL CONSEQUENTIAL DAMAGES ARISING USE INABILITY USE PROGRAM (INCLUDING LIMITED LOSS DATA DATA RENDERED INACCURATE LOSSES SUSTAINED THIRD PARTIES FAILURE PROGRAM OPERATE PROGRAMS), EVEN HOLDER PARTY ADVISED POSSIBILITY DAMAGES.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"id_17-interpretation-of-sections-15-and-16","dir":"","previous_headings":"TERMS AND CONDITIONS","what":"17. Interpretation of Sections 15 and 16","title":"GNU General Public License","text":"disclaimer warranty limitation liability provided given local legal effect according terms, reviewing courts shall apply local law closely approximates absolute waiver civil liability connection Program, unless warranty assumption liability accompanies copy Program return fee. END TERMS CONDITIONS","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/LICENSE.html","id":"how-to-apply-these-terms-to-your-new-programs","dir":"","previous_headings":"","what":"How to Apply These Terms to Your New Programs","title":"GNU General Public License","text":"develop new program, want greatest possible use public, best way achieve make free software everyone can redistribute change terms. , attach following notices program. safest attach start source file effectively state exclusion warranty; file least “copyright” line pointer full notice found. Also add information contact electronic paper mail. program terminal interaction, make output short notice like starts interactive mode: hypothetical commands show w show c show appropriate parts General Public License. course, program’s commands might different; GUI interface, use “box”. also get employer (work programmer) school, , sign “copyright disclaimer” program, necessary. information , apply follow GNU GPL, see <http://www.gnu.org/licenses/>. GNU General Public License permit incorporating program proprietary programs. program subroutine library, may consider useful permit linking proprietary applications library. want , use GNU Lesser General Public License instead License. first, please read <http://www.gnu.org/philosophy/--lgpl.html>.","code":"<one line to give the program's name and a brief idea of what it does.> Copyright (C) <year>  <name of author>  This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. <program>  Copyright (C) <year>  <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type 'show w'. This is free software, and you are welcome to redistribute it under certain conditions; type 'show c' for details."},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/articles/restoptr.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting started","text":"Habitat restoration urgently need prevent declines biodiversity (Chazdon et al. 2017; Strassburg et al. 2020). Since resources available restoring habitat limited, plans restoring habitat (hereafter, “restoration prioritizations”) need achieve conservation objectives minimal cost (Strassburg et al. 2019). Indeed, restoration prioritizations need strategically site restoration actions places enhance connectivity among remaining habitats (Correa Ayram et al. 2016). also need account existing land-use constraints prevent actions implemented particular places (e.g., places heavily modified conservation activities) (Margules & Pressey 2000). Since accounting considerations exploring trade-offs can difficult, decision support tools can play important role conservation decision making (Flower et al. 2020; Janßen et al. 2019; Jumin et al. 2018). provide tutorial using restoptr R package ecological restoration planning. Briefly, uses optimization algorithms generate restoration prioritizations (based Justeau-Allaire et al. 2021). can identified maximizing landscape indices, effective mesh size (Jaeger 2000), integral index connectivity (Pascual-Hortal & Saura 2006). Additionally, constraints can used ensure priority areas exhibit particular characteristics (e.g., ensure particular places selected restoration, ensure priority areas form single contiguous network). Furthermore, multiple near-optimal solutions can generated explore multiple options restoration planning. package leverages Choco-solver software perform optimization using constraint programming (CP) techniques (Prud’homme et al. 2016).","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/articles/restoptr.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Getting started","text":"Let’s setup R session tutorial. , load restoptr R package. also load terra R package working raster data, vegan cluster R packages comparing prioritizations. Additionally, set seed random number generator help ensure consistent results. Since package needs Java work, let’s verify Java installed. previous code returns TRUE, means Java installed computer ready use. , please see package README documentation instructions installing setting Java (see https://github.com/dimitri-justeau/restoptr). Assuming Java installed correctly, can proceed tutorial.","code":"# load packages library(restoptr) library(terra) library(vegan) library(cluster) library(ggthemes)  # set seed for reproducibility set.seed(500) # check if Java is available for usage is_java_available() ## [1] TRUE"},{"path":"https://dimitri-justeau.github.io/restoptr/articles/restoptr.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Getting started","text":"Let’s import data generating restoration prioritizations. Specifically, use example dataset distributed package (obtained Justeau-Allaire et al. 2021). dataset contains data prioritizing forest restoration efforts within protected area New Caledonia. begin , let’s import raster layer describe spatial distribution existing habitat across study area. raster layer (.e., habitat_data) contains binary values (zeros ones) indicating places (0) contain existing habitat (1) currently contain existing habitat. raster layer also contains places missing (NA) values, represent places considered part prioritization exercise (e.g., places located outside study area).  Next, let’s import raster layer describe spatial distribution places inside study area available restoration activities. example, places include places restoration efforts costly implement, places restoration possible needed land-uses (e.g., places needed urban development). Similar previous raster layer, raster layer (.e., locked_out_data) contains binary values (zeros ones) indicating places (0) suitable restoration actions (1) suitable restoration actions. raster layer also contains missing (NA) values places previous layer.  loading data, can begin formulating optimization problem.","code":"# load habitat data habitat_data <- rast(system.file(   \"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\" ))  # preview habitat data print(habitat_data) ## class       : SpatRaster  ## dimensions  : 1867, 2713, 1  (nrow, ncol, nlyr) ## resolution  : 27.9487, 29.74339  (x, y) ## extent      : 419768.2, 495593.1, 227538.9, 283069.8  (xmin, xmax, ymin, ymax) ## coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  ## source      : habitat_hi_res.tif  ## name        : habitat_hi_res # visualize habitat data plot(habitat_data, main = \"Existing habitat\",  plg = list(x = \"topright\")) # load locked out data locked_out_data <- rast(system.file(   \"extdata\", \"locked_out.tif\", package = \"restoptr\" ))  # preview locked out data print(locked_out_data) ## class       : SpatRaster  ## dimensions  : 1867, 2713, 1  (nrow, ncol, nlyr) ## resolution  : 27.9487, 29.74339  (x, y) ## extent      : 419768.2, 495593.1, 227538.9, 283069.8  (xmin, xmax, ymin, ymax) ## coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  ## source      : locked_out.tif  ## name        : layer  ## min value   :     1  ## max value   :     1 # visualize locked out data plot(locked_out_data, main = \"Locked out areas\", plg = list(x = \"topright\"), col=c(\"darkorange\"))"},{"path":"https://dimitri-justeau.github.io/restoptr/articles/restoptr.html","id":"problem-formulation","dir":"Articles","previous_headings":"","what":"Problem formulation","title":"Getting started","text":"Now let’s formulate restoration optimization problem. achieve , build object contains data settings needed perform optimization process. First, create object underlying data (using restopt_problem() function). , specify using habitat_data raster layer specify spatial distribution existing habitat (via existing_habitat parameter). also specify data internally aggregated (using factor 16) reduce computational processing (via aggregation_factor parameter). Additionally, specify – following data aggregation – places must contain least 70% habitat considered adequately managed biodiversity (via habitat_threshold parameter). Second, specify objective function – metric used compare competing solutions – connectivity metric known effective mesh size statistic (via set_max_mesh_objective() function) (Jaeger 2000). Third, specify total amount land selected restoration exceed 220 ha (via add_restorable_constraint() function). Fourth, specify spatial extent priority areas must exceed 2.5 km (via add_compactness_constraint() function). Fifth, specify particular places – per locked_out_data raster layer – selected restoration activities (via add_locked_out_constraint() function). Finally, specify wish generate single optimal prioritization (via add_settings() function). building problem formulation object, can solve .","code":"# build problem rp <-   restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_max_mesh_objective() %>%   add_restorable_constraint(     min_restore = 1, max_restore = 220, unit = \"ha\"   ) %>%   add_compactness_constraint(2.5, unit = \"km\") %>%   add_locked_out_constraint(data = locked_out_data) %>%   add_settings(optimality_gap = 0)  # preview problem print(rp) ## -----------------------------------------------------------------  ##                          Restopt                           ## -----------------------------------------------------------------  ## original habitat:     habitat_hi_res.tif  ## aggregation factor:   16  ## habitat threshold:    0.7  ## existing habitat:     in memory  ## restorable habitat:   in memory  ## -----------------------------------------------------------------  ## objective:            Maximize effective mesh size  ## -----------------------------------------------------------------  ## constraints:           ##   -  restorable (min_restore = 1, max_restore = 220, min_proportion = 1, unit = ha)  ##   -  compactness (max_diameter = 2.5, unit = km)  ##   -  locked out (data = in memory)  ## -----------------------------------------------------------------  ## settings:  ##   - precision = 4 ##   - time_limit = 0 ##   - nb_solutions = 1 ##   - optimality_gap = 0 ##   - solution_name_prefix = Solution   ## -----------------------------------------------------------------"},{"path":"https://dimitri-justeau.github.io/restoptr/articles/restoptr.html","id":"generating-a-prioritization","dir":"Articles","previous_headings":"","what":"Generating a prioritization","title":"Getting started","text":"can generate prioritization solving restoration problem object (.e., rp).  can see prioritization selected planning units restoration southern region study area (shown blue). restoring habitat inside planning units, restoration efforts link two large patches existing habitat (shown green, located north south prioritization). Thus prioritization identified set priority areas produce single extremely large patch habitat—substantially improving connectivity within study area. generating prioritization, can also extract metadata . metadata describe spatial extent priority areas, ability promote connectivity according various metrics. Although prioritization identifies set places – combination – can help promote connectivity, necessarily tell us places (less) important achieving objective.","code":"# solve problem to generate prioritization rs <- solve(rp) ## Good news: the solver found 1 solution statisfying the constraints that was proven optimal ! (solving time = 1.4 s) # preview prioritization print(rs) ## class       : RestoptSolution  ## dimensions  : 117, 170, 1  (nrow, ncol, nlyr) ## resolution  : 447.1792, 475.8943  (x, y) ## extent      : 419768.2, 495788.7, 227390.1, 283069.8  (xmin, xmax, ymin, ymax) ## coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  ## source(s)   : memory ## categories  : label  ## name        :  Solution 1  ## min value   :  Locked out  ## max value   : Restoration # display summary statistics for the prioritization print(get_metadata(rs)) ##     min_restore total_restorable nb_planning_units nb_components     diameter ## 1 219.0447 [ha]    219.0447 [ha]                16             2 2499.808 [m] ##   optimality_proven search_state solving_time  mesh_initial          mesh ## 1              TRUE   TERMINATED        1.381 13667.84 [ha] 14248.14 [ha] ##       mesh_best ## 1 14248.14 [ha] # visualize prioritization ## here, values indicate: ## 0 : places that were locked out. ## 1 : places that were potential candidates for restoration ## 2 : places that already contain existing habitat. ## 3 : places selected for restoration actions. plot(   rs, main = \"Optimal prioritization\",   col = c(\"#E5E5E5\", \"#fff1d6\", \"#b2df8a\", \"#1f78b4\"),   plg = list(x = \"topright\") ) # extract metadata get_metadata(rs) ##     min_restore total_restorable nb_planning_units nb_components     diameter ## 1 219.0447 [ha]    219.0447 [ha]                16             2 2499.808 [m] ##   optimality_proven search_state solving_time  mesh_initial          mesh ## 1              TRUE   TERMINATED        1.381 13667.84 [ha] 14248.14 [ha] ##       mesh_best ## 1 14248.14 [ha]"},{"path":"https://dimitri-justeau.github.io/restoptr/articles/restoptr.html","id":"relative-importance","dir":"Articles","previous_headings":"","what":"Relative importance","title":"Getting started","text":"can assess relative importance places restoring connectivity. information useful help facilitate stakeholder discussions determine places prioritization scheduled immediately restoration. assess relative importance, generate portfolio optimal prioritizations calculate number times planning unit selected prioritization. approach similar selection frequency statistics provided Marxan decision support tool conservation planning (Ball et al. 2009).  can see planning units critical implementing optimal prioritization (shown dark green) planning units important (shown yellow pink). addition evaluating relative importance, can also generate portfolios explore alternative options restoration.","code":"# generate multiple prioritizations for assessing relative importance prt_imp <-   rp %>%   add_settings(nb = 100, optimality_gap = 0) %>%   solve(verbose = FALSE) %>%   rast() # preview portfolio prioritizations print(prt_imp) ## class       : RestoptSolution  ## dimensions  : 117, 170, 8  (nrow, ncol, nlyr) ## resolution  : 447.1792, 475.8943  (x, y) ## extent      : 419768.2, 495788.7, 227390.1, 283069.8  (xmin, xmax, ymin, ymax) ## coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  ## source(s)   : memory ## names       :  Solution 1,  Solution 2,  Solution 3,  Solution 4,  Solution 5,  Solution 6, ...  ## min values  :  Locked out,  Locked out,  Locked out,  Locked out,  Locked out,  Locked out, ...  ## max values  : Restoration, Restoration, Restoration, Restoration, Restoration, Restoration, ... # calculate selection frequency of from portfolio selfreq <- sum(prt_imp == 3)  # preview selection frequency data print(selfreq) ## class       : SpatRaster  ## dimensions  : 117, 170, 1  (nrow, ncol, nlyr) ## resolution  : 447.1792, 475.8943  (x, y) ## extent      : 419768.2, 495788.7, 227390.1, 283069.8  (xmin, xmax, ymin, ymax) ## coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  ## source(s)   : memory ## name        : sum  ## min value   :   0  ## max value   :   8 # visualize selection frequencies plot(selfreq, main = \"Selection frequencies\", type = \"continuous\")"},{"path":"https://dimitri-justeau.github.io/restoptr/articles/restoptr.html","id":"exploring-alternatives","dir":"Articles","previous_headings":"","what":"Exploring alternatives","title":"Getting started","text":"Spatial conservation planning exercises can help facilitate stakeholder discussions presenting range alternate prioritizations. stakeholders might additional objectives previously communicated (e.g., conservation particular charismatic species), existing data may insufficient fully parametrize objectives (e.g., although stakeholder might value particular ecosystem service, data may exist incorporate ecosystem service prioritization process). , can useful generate set multiple prioritizations (roughly) similar performance exhibit different spatial configurations. , let’s generate second portfolio prioritizations. Since aim identify alternate spatial configurations relatively similar performance, generate prioritizations range different optimality gaps (.e., ranging 0% 15%). Although generated portfolio different prioritizations, ’s difficult tell exactly prioritizations different . Although try viewing prioritizations one one, isn’t really practical. , let’s conduct statistical analysis visualize differences among planning units – based planning units selected – using hierarchical cluster analysis (Harris et al. 2014).  can see two main groups prioritizations portfolio. identify prioritizations within groups, let’s conduct k-medoids cluster analysis extract typical prioritization within group.  can see first prioritization (shown top) similar optimal solution generated previously. Indeed – similar optimal prioritization – prioritization selected set planning units link two patches existing habitat southern region study area. However, second prioritizations (shown bottom) selected set planning units central region study area. prioritization identified different set planning units link patches existing habitat. Since prioritizations within 15% optimality (per greatest optimality gap used generate portfolio), roughly performance.","code":"# define optimality gaps gap_values <- seq(0, 0.15, 0.1)  # generate portfolio of prioritizations prt_alt <-   lapply(gap_values, function(x) {     rp %>%     add_settings(       nb = 10,       optimality_gap = x,       solution_name_prefix = paste0(\"opt_gap_\", x, \"__#\")     ) %>%     solve(v, verbose = FALSE)   }) %>%   unlist(recursive = FALSE, use.names = FALSE) %>%   rast()  # preview portfolio print(prt_alt) ## class       : RestoptSolution  ## dimensions  : 117, 170, 18  (nrow, ncol, nlyr) ## resolution  : 447.1792, 475.8943  (x, y) ## extent      : 419768.2, 495788.7, 227390.1, 283069.8  (xmin, xmax, ymin, ymax) ## coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  ## source(s)   : memory ## names       : opt_g~0__#1, opt_g~0__#2, opt_g~0__#3, opt_g~0__#4, opt_g~0__#5, opt_g~0__#6, ...  ## min values  :  Locked out,  Locked out,  Locked out,  Locked out,  Locked out,  Locked out, ...  ## max values  : Restoration, Restoration, Restoration, Restoration, Restoration, Restoration, ... # extract prioritization values prt_values <- as.data.frame(prt_alt == 3)  # calculate pair-wise distances between different prioritizations for analysis prt_dists <- vegdist(t(prt_values), method = \"jaccard\", binary = TRUE)  # run cluster analysis prt_clust <- hclust(as.dist(prt_dists), method = \"average\")  # visualize clusters withr::with_par(   list(oma = c(0, 0, 0, 0), mar = c(0, 4.1, 1.5, 2.1)),   plot(     prt_clust, labels = FALSE, sub = NA, xlab = \"\",     main = \"Cluster analysis of prioritizations in portfolio\"   ) ) # run k-medoids analysis prt_med <- pam(prt_dists, k = 2)  # extract names of prioritizations that are most central for each group prt_med_names <- prt_med$medoids print(prt_med_names) ## [1] \"opt_gap_0__#5\"   \"opt_gap_0.1__#1\" # create a new portfolio based on these prioritizations prt_cand <- prt_alt[[prt_med_names]]  # visualize prioritizations in subset portfolio ## here, values indicate: ## 0 : places that were locked out. ## 1 : places that were potential candidates for restoration ## 2 : places that already contain existing habitat. ## 3 : places selected for restoration actions. plot(   prt_cand, col = c(\"#E5E5E5\", \"#fff1d6\", \"#b2df8a\", \"#1f78b4\"),   plg = list(x = \"topright\"), nc = 1 )"},{"path":"https://dimitri-justeau.github.io/restoptr/articles/restoptr.html","id":"evaluating-trade-offs","dir":"Articles","previous_headings":"","what":"Evaluating trade-offs","title":"Getting started","text":"Conservation decision making fundamentally involves making trade-offs multiple objectives. , main trade-() maximizing level connectivity can promoted restoring habitats (ii) minimizing total cost restoration actions. Specifically, consider total cost reflected total area planning units selected restoration. trade-can particularly acute, wherein large gains connectivity can achieved minor increase cost. , can useful understand increasing maximum amount land available restoration can influence connectivity. explore , generate portfolio prioritizations using different constraints measure performance. Since interested exploring trade-offs – rather alternate prioritizations – specify optimality gap 0%.  can see prioritizations within portfolio similar first optimal prioritization generated start tutorial. Indeed, focus restoration efforts connecting two large patches existing habitat southern region study area. mainly differ terms number planning units selected restoration, prioritizations generated higher maximum amount land (e.g., max_restore = 450) restoring larger contiguous block land two patches existing habitat. help understand relationship better, let’s create plot.  can see steady increase connectivity (measured effective mesh size metric) maximum amount land can restored. means restoring land can result connectivity. Interestingly, also see level connectivity reaches plateau approximately 350 ha land. – looking prt_tradeoffs_metedata – can see largest amount land restored prioritization 336.67 ha. Although prioritizations generated using higher maximum restoreable area constraint (e.g., 450 ha), compactness locked constraints combined prevent larger amount land selected restoration. Thus can see multiple constraints can, combination, affect ability restoration efforts achieve conservation objectives.","code":"# define a set of different maximum area values for generating prioritizations ## N.B. these values are in hectares max_restore_values <- seq(100, 450, 10)  # build a baseline problem without restorable constraints bp <-   restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_max_mesh_objective() %>%   add_compactness_constraint(2.5, unit = \"km\") %>%   add_locked_out_constraint(data = locked_out_data) %>%   add_settings(optimality_gap = 0)  # generate a portfolio of prioritizations to explore trade-offs prt_tradeoffs <- lapply(max_restore_values, function(x) {   bp %>%   add_restorable_constraint(min_restore = 1, max_restore = x, unit = \"ha\") %>%   solve(verbose = FALSE) }) # extract metadata for each prioritization prt_tradeoffs_metedata <- do.call(rbind, lapply(prt_tradeoffs, get_metadata)) prt_tradeoffs_metedata$max_restore <- max_restore_values  # print metadata print(prt_tradeoffs_metedata) ##       min_restore total_restorable nb_planning_units nb_components     diameter ## 1   99.67156 [ha]    99.67156 [ha]                 9             5 2466.877 [m] ## 2  109.73016 [ha]   109.73016 [ha]                 9             5 2455.824 [m] ## 3  115.05041 [ha]   115.05041 [ha]                10             4 2466.877 [m] ## 4  129.09920 [ha]   129.09920 [ha]                11             5 2466.877 [m] ## 5  138.16025 [ha]   138.16025 [ha]                11             4 2499.808 [m] ## 6  148.63449 [ha]   148.63449 [ha]                12             5 2466.877 [m] ## 7  159.02561 [ha]   159.02561 [ha]                12             3 2499.808 [m] ## 8  169.74924 [ha]   169.74924 [ha]                13             4 2499.808 [m] ## 9  177.56335 [ha]   177.56335 [ha]                13             4 2432.582 [m] ## 10 189.28453 [ha]   189.28453 [ha]                14             4 2499.808 [m] ## 11 198.67810 [ha]   198.67810 [ha]                15             3 2499.808 [m] ## 12 207.32350 [ha]   207.32350 [ha]                15             3 2474.054 [m] ## 13 219.04468 [ha]   219.04468 [ha]                16             2 2499.808 [m] ## 14 229.18641 [ha]   229.18641 [ha]                16             4 2474.054 [m] ## 15 237.33304 [ha]   237.33304 [ha]                17             3 2499.808 [m] ## 16 249.38673 [ha]   249.38673 [ha]                17             2 2499.808 [m] ## 17 259.36220 [ha]   259.36220 [ha]                18             2 2499.808 [m] ## 18 267.25945 [ha]   267.25945 [ha]                18             2 2474.054 [m] ## 19 276.98553 [ha]   276.98553 [ha]                19             3 2499.808 [m] ## 20 289.53800 [ha]   289.53800 [ha]                19             2 2466.877 [m] ## 21 296.02205 [ha]   296.02205 [ha]                20             2 2499.808 [m] ## 22 308.49139 [ha]   308.49139 [ha]                20             2 2499.808 [m] ## 23 316.55489 [ha]   316.55489 [ha]                21             2 2499.808 [m] ## 24 317.13679 [ha]   317.13679 [ha]                21             2 2499.808 [m] ## 25 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 26 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 27 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 28 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 29 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 30 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 31 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 32 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 33 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 34 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 35 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ## 36 336.67209 [ha]   336.67209 [ha]                22             2 2499.808 [m] ##    optimality_proven search_state solving_time  mesh_initial          mesh ## 1               TRUE   TERMINATED        3.183 13667.84 [ha] 14124.59 [ha] ## 2               TRUE   TERMINATED        2.791 13667.84 [ha] 14124.59 [ha] ## 3               TRUE   TERMINATED        3.268 13667.84 [ha] 14140.00 [ha] ## 4               TRUE   TERMINATED        2.389 13667.84 [ha] 14155.43 [ha] ## 5               TRUE   TERMINATED        2.817 13667.84 [ha] 14155.43 [ha] ## 6               TRUE   TERMINATED        1.683 13667.84 [ha] 14170.86 [ha] ## 7               TRUE   TERMINATED        1.221 13667.84 [ha] 14186.29 [ha] ## 8               TRUE   TERMINATED        1.186 13667.84 [ha] 14201.74 [ha] ## 9               TRUE   TERMINATED        1.266 13667.84 [ha] 14201.74 [ha] ## 10              TRUE   TERMINATED        1.019 13667.84 [ha] 14217.20 [ha] ## 11              TRUE   TERMINATED        1.179 13667.84 [ha] 14217.20 [ha] ## 12              TRUE   TERMINATED        0.775 13667.84 [ha] 14232.66 [ha] ## 13              TRUE   TERMINATED        0.486 13667.84 [ha] 14248.14 [ha] ## 14              TRUE   TERMINATED        0.549 13667.84 [ha] 14248.14 [ha] ## 15              TRUE   TERMINATED        0.378 13667.84 [ha] 14263.62 [ha] ## 16              TRUE   TERMINATED        0.380 13667.84 [ha] 14263.62 [ha] ## 17              TRUE   TERMINATED        0.196 13667.84 [ha] 14279.12 [ha] ## 18              TRUE   TERMINATED        0.321 13667.84 [ha] 14279.12 [ha] ## 19              TRUE   TERMINATED        0.382 13667.84 [ha] 14294.62 [ha] ## 20              TRUE   TERMINATED        0.270 13667.84 [ha] 14294.62 [ha] ## 21              TRUE   TERMINATED        0.334 13667.84 [ha] 14310.13 [ha] ## 22              TRUE   TERMINATED        0.224 13667.84 [ha] 14310.13 [ha] ## 23              TRUE   TERMINATED        0.297 13667.84 [ha] 14325.65 [ha] ## 24              TRUE   TERMINATED        0.259 13667.84 [ha] 14325.65 [ha] ## 25              TRUE   TERMINATED        0.231 13667.84 [ha] 14341.18 [ha] ## 26              TRUE   TERMINATED        0.156 13667.84 [ha] 14341.18 [ha] ## 27              TRUE   TERMINATED        0.166 13667.84 [ha] 14341.18 [ha] ## 28              TRUE   TERMINATED        0.223 13667.84 [ha] 14341.18 [ha] ## 29              TRUE   TERMINATED        0.213 13667.84 [ha] 14341.18 [ha] ## 30              TRUE   TERMINATED        0.313 13667.84 [ha] 14341.18 [ha] ## 31              TRUE   TERMINATED        0.235 13667.84 [ha] 14341.18 [ha] ## 32              TRUE   TERMINATED        0.234 13667.84 [ha] 14341.18 [ha] ## 33              TRUE   TERMINATED        0.217 13667.84 [ha] 14341.18 [ha] ## 34              TRUE   TERMINATED        0.269 13667.84 [ha] 14341.18 [ha] ## 35              TRUE   TERMINATED        0.244 13667.84 [ha] 14341.18 [ha] ## 36              TRUE   TERMINATED        0.241 13667.84 [ha] 14341.18 [ha] ##        mesh_best max_restore ## 1  14124.59 [ha]         100 ## 2  14124.59 [ha]         110 ## 3  14140.00 [ha]         120 ## 4  14155.43 [ha]         130 ## 5  14155.43 [ha]         140 ## 6  14170.86 [ha]         150 ## 7  14186.29 [ha]         160 ## 8  14201.74 [ha]         170 ## 9  14201.74 [ha]         180 ## 10 14217.20 [ha]         190 ## 11 14217.20 [ha]         200 ## 12 14232.66 [ha]         210 ## 13 14248.14 [ha]         220 ## 14 14248.14 [ha]         230 ## 15 14263.62 [ha]         240 ## 16 14263.62 [ha]         250 ## 17 14279.12 [ha]         260 ## 18 14279.12 [ha]         270 ## 19 14294.62 [ha]         280 ## 20 14294.62 [ha]         290 ## 21 14310.13 [ha]         300 ## 22 14310.13 [ha]         310 ## 23 14325.65 [ha]         320 ## 24 14325.65 [ha]         330 ## 25 14341.18 [ha]         340 ## 26 14341.18 [ha]         350 ## 27 14341.18 [ha]         360 ## 28 14341.18 [ha]         370 ## 29 14341.18 [ha]         380 ## 30 14341.18 [ha]         390 ## 31 14341.18 [ha]         400 ## 32 14341.18 [ha]         410 ## 33 14341.18 [ha]         420 ## 34 14341.18 [ha]         430 ## 35 14341.18 [ha]         440 ## 36 14341.18 [ha]         450 # convert portfolio into a stack of rasters prt_tradeoffs <- rast(prt_tradeoffs)  # preview portfolio print(prt_tradeoffs) ## class       : RestoptSolution  ## dimensions  : 117, 170, 36  (nrow, ncol, nlyr) ## resolution  : 447.1792, 475.8943  (x, y) ## extent      : 419768.2, 495788.7, 227390.1, 283069.8  (xmin, xmax, ymin, ymax) ## coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  ## source(s)   : memory ## names       :  Solution 1,  Solution 1,  Solution 1,  Solution 1,  Solution 1,  Solution 1, ...  ## min values  :  Locked out,  Locked out,  Locked out,  Locked out,  Locked out,  Locked out, ...  ## max values  : Restoration, Restoration, Restoration, Restoration, Restoration, Restoration, ... # visualize some of the prioritizations in portfolio ## here, titles indicate maximum area and values indicate: ## 0 : places that were locked out. ## 1 : places that were potential candidates for restoration ## 2 : places that already contain existing habitat. ## 3 : places selected for restoration actions. plot_idx <- round(seq(1, length(max_restore_values), length.out = 9)) plot(   prt_tradeoffs[[plot_idx]],   main = paste(\"max_restore = \", max_restore_values[plot_idx]),   col = c(\"#E5E5E5\", \"#fff1d6\", \"#b2df8a\", \"#1f78b4\"),   plg = list(x = \"topright\") ) # create plot showing relationship between restorable area and connectivity ## N.B. the prioritization corresponding to a maximum restorable area of 220 ## is shown in red, which is the same value used for previous prioritizations plot(   mesh_best ~ max_restore_values,   data = prt_tradeoffs_metedata,   xlab = \"Area restored (ha)\",   ylab = \"Connectivity (mesh statistic)\",   pch = 16,   col = ifelse(prt_tradeoffs_metedata$max_restore == 200, \"red\", \"black\") )"},{"path":"https://dimitri-justeau.github.io/restoptr/articles/restoptr.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Getting started","text":"Hopefully, tutorial provided useful introduction restoptr R package. information using package, please consult package documentation provides examples functions. questions using package, suggestions improving , encounter bugs, please open issue online code repository.","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dimitri Justeau-Allaire. Author, maintainer. Jeffrey O Hanson. Author. Ghislain Vieilledent. Author. Philippe Vismara. Author. Xavier Lorca. Author. Philippe Birnbaum. Author.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Justeau-Allaire D, Vieilledent G, Rinck N, Vismara P, Lorca X & Birnbaum P (2021) Constrained optimization landscape indices conservation planning support ecological restoration New Caledonia. Journal Applied Ecology, 58(4), 744‑754.","code":"@Article{,   author = {D Justeau-Allaire and G Vieilledent and N Rinck and P Vismara and X Lorca and P Birnbaum},   title = {Constrained optimization of landscape indices in conservation planning to support ecological restoration in New Caledonia},   journal = {Journal of Applied Ecology},   year = {2021},   volume = {58},   number = {4},   pages = {744-754},   doi = {10.1111/1365-2664.13803}, }"},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"ecological-restoration-planning","dir":"","previous_headings":"","what":"Ecological Restoration Planning","title":"Ecological Restoration Planning","text":"Logo Camille Salmon","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Ecological Restoration Planning","text":"restoptr R package provides flexible framework ecological restoration planning. aims identify priority areas restoration efforts using optimization algorithms (based Justeau-Allaire et al. 2021). Priority areas can identified maximizing landscape indices, effective mesh size (Jaeger 2000), integral index connectivity (Pascual-Hortal & Saura 2006). Additionally, constraints can used ensure priority areas exhibit particular characteristics (e.g., ensure particular places selected restoration, ensure priority areas form single contiguous network). Furthermore, multiple near-optimal solutions can generated explore multiple options restoration planning. package leverages Choco-solver software perform optimization using constraint programming (CP) techniques (Prud’homme et al. 2016).","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"package-installation","dir":"","previous_headings":"Installation","what":"Package installation","title":"Ecological Restoration Planning","text":"latest official version restoptr R package can installed Comprehensive R Archive Network (CRAN) using following R code. Alternatively, latest developmental version can installed using following R code. Please note developmental versions may contain additional features present official version, may also contain coding errors.","code":"install.packages(\"restoptr\", repos = \"https://cran.rstudio.com/\") if (!require(remotes)) install.packages(\"remotes\") remotes::install_github(\"dimitri-justeau/restoptr\")"},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"system-dependencies","dir":"","previous_headings":"Installation","what":"System dependencies","title":"Ecological Restoration Planning","text":"packages requires Java Runtime Environment (JRE), version 8 higher. provide platform-specific instructions install .","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"windows","dir":"","previous_headings":"Installation > System dependencies","what":"Windows","title":"Ecological Restoration Planning","text":"Please install latest Java Runtime Environment Windows (see Oracle JDK, OpenJDK, GraalVM). also need install Maven. downloading file, please run installer install Java system. also need ensure PATH environmental variable configured R can access Java. restoptr relies rJava communication R Java. trouble installation restopt due rJava, please refer rJava’s documentation: https://rforge.net/rJava/index.html.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"ubuntu","dir":"","previous_headings":"Installation > System dependencies","what":"Ubuntu","title":"Ecological Restoration Planning","text":"recent versions Ubuntu (18.04 later), Java libraries available official repositories. can installed using following system commands. want install specific JRE version, please follow instructions Oracle, OpenJDK, GraalVM.","code":"sudo apt-get install default-jdk"},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"linux","dir":"","previous_headings":"Installation > System dependencies","what":"Linux","title":"Ecological Restoration Planning","text":"Please follow instructions Oracle, OpenJDK, GraalVM.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"macos","dir":"","previous_headings":"Installation > System dependencies","what":"MacOS","title":"Ecological Restoration Planning","text":"easiest way install Java libraries using HomeBrew. installing HomeBrew, Java libraries can installed using following system commands. Please note might also need ensure PATH environmental variable configured R can access Java.","code":"brew install openjdk"},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"building-the-java-core-library-from-source-optional","dir":"","previous_headings":"Installation","what":"Building the Java core library from source (optional)","title":"Ecological Restoration Planning","text":"package relies core Java library called restopt. Java library handles constrained optimization process via Choco-solver software. Although library automatically included package, can manually compile source needed. Please note step entirely optional, needed install package. compile Java library, Maven software needs installed well Java Development Kit (JDK) (version 8+) required (e.g., see Oracle JDK, OpenJDK, GraalVM). installing dependencies, following procedures can used compile Java library along package. First clone repository update source code. Next, compile core Java library Maven. Next, copy resulting Java library (.jar) file java directory. Finally, package can installed newly compiled Java library using following R command.","code":"git clone https://github.com/dimitri-justeau/restoptr.git cd restoptr git submodule update --init --recursive git pull --recurse-submodules cd restopt mvn clean package -DskipTests cp target/restopt-*.jar ../java/ if (!require(remotes)) install.packages(\"remotes\") remotes::install_local(\".\")"},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Ecological Restoration Planning","text":"provide short tutorial using restoptr R package identify priority areas restoration. part tutorial, use example dataset distributed package (obtained Justeau-Allaire et al. 2021). example dataset contains data prioritizing forest restoration efforts within protected area New Caledonia. begin tutorial loading package. haven’t already, please install package (see installation instructions). identify priorities restoration, require information location places currently contain suitable habitat. now import data describe places within protected area contain forest habitat (imported habitat_data object). Specifically, object spatial grid (.e., raster layer). grid cell corresponds candidate place restoration (termed planning unit), values indicate absence presence forest within planning unit (using values zero one, respectively).  Restoration efforts often limited terms places can implemented. example, restoration efforts may feasible dense cities. example, places feasible restoration accessed existing tracks within protected area. now import data describe places feasible restoration (imported locked_out_data object). object – similar habitat data – spatial grid. grid cell values object indicate planning units considered available restoration (using values zero one, respectively).  now build restoration optimization problem (stored problem object). object specify data, settings, optimization criteria identifying priority areas. Specifically, initialize problem habitat_data object specify planning units already contain suitable habitat (restopt_problem() function). reduce run time, also initialize parameters aggregate spatial data (.e., aggregation_factor habitat_threshold). Next, specify objective function optimization process maximize connectivity based effective mesh size metric (set_max_mesh_objective() function). specify constraints ensure priority areas exhibit particular characteristics. constraints used ensure () certain planning units selected restoration (add_locked_out_constraint() function), (ii) total amount restored area range 90 220 ha (add_restorable_constraint() function), (iii) limit spatial extent priority areas within 2.4 km (add_compactness_constraint() function). building problem, can solve identify priority areas restoration (solve() function). solution raster layer containing values indicate planning units: (0) locked , (1) contain existing habitat, (2) contain existing habitat, (3) selected priority area restoration.  Finally, can access additional information solution (get_metadata() function). just short taster package. extended tutorial using package, please refer vignette.","code":"# load package library(restoptr) # import data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # preview data print(habitat_data) ## class       : SpatRaster  ## dimensions  : 1867, 2713, 1  (nrow, ncol, nlyr) ## resolution  : 27.9487, 29.74339  (x, y) ## extent      : 419768.2, 495593.1, 227538.9, 283069.8  (xmin, xmax, ymin, ymax) ## coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  ## source      : habitat_hi_res.tif  ## name        : habitat_hi_res # visualize data plot(habitat_data, plg = list(x = \"topright\")) # import data locked_out_data <- rast(   system.file(\"extdata\", \"locked_out.tif\", package = \"restoptr\") )  # preview data print(locked_out_data) ## class       : SpatRaster  ## dimensions  : 1867, 2713, 1  (nrow, ncol, nlyr) ## resolution  : 27.9487, 29.74339  (x, y) ## extent      : 419768.2, 495593.1, 227538.9, 283069.8  (xmin, xmax, ymin, ymax) ## coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  ## source      : locked_out.tif  ## name        : layer  ## min value   :     1  ## max value   :     1 # visualize data plot(locked_out_data, plg = list(x = \"topright\")) # build restoration optimization problem problem <-   ## initialize problem with habitat data   restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   ## set objective function is to maximize effective mesh size   set_max_mesh_objective() %>%   ## add constraint to ensure that certain places are not selected   add_locked_out_constraint(locked_out_data) %>%   ## add constraint to limit total amount of restored area   add_restorable_constraint(90, 220, unit = \"ha\") %>%   ## add constraint to limit spatial extent of priority areas   add_compactness_constraint(2.4, unit = \"km\")  # preview problem print(problem) ## -----------------------------------------------------------------  ##                          Restopt                           ## -----------------------------------------------------------------  ## original habitat:     habitat_hi_res.tif  ## aggregation factor:   16  ## habitat threshold:    0.7  ## existing habitat:     in memory  ## restorable habitat:   in memory  ## -----------------------------------------------------------------  ## objective:            Maximize effective mesh size  ## -----------------------------------------------------------------  ## constraints:           ##   -  locked out (data = in memory)  ##   -  restorable (min_restore = 90, max_restore = 220, min_proportion = 1, unit = ha)  ##   -  compactness (max_diameter = 2.4, unit = km)  ## -----------------------------------------------------------------  ## settings:  ##   - precision = 4 ##   - time_limit = 0 ##   - nb_solutions = 1 ##   - optimality_gap = 0 ##   - solution_name_prefix = Solution   ## ----------------------------------------------------------------- # solve problem to identify priority areas solution <- solve(problem) ## Good news: the solver found 1 solution statisfying the constraints that was proven optimal ! (solving time = 0.97 s) # preview solution print(solution) ## class       : RestoptSolution  ## dimensions  : 117, 170, 1  (nrow, ncol, nlyr) ## resolution  : 447.1792, 475.8943  (x, y) ## extent      : 419768.2, 495788.7, 227390.1, 283069.8  (xmin, xmax, ymin, ymax) ## coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  ## source(s)   : memory ## categories  : label  ## name        :  Solution 1  ## min value   :  Locked out  ## max value   : Restoration # visualize solution plot(   solution,   main = \"Solution\",   col = c(\"#E5E5E5\", \"#fff1d6\", \"#b2df8a\", \"#1f78b4\"),   plg = list(x = \"topright\") ) # access information on the solution ## N.B. spatial units are expressed as hectares get_metadata(solution, area_unit = \"ha\") ##     min_restore total_restorable nb_planning_units nb_components     diameter ## 1 219.3772 [ha]    219.3772 [ha]                15             3 2280.175 [m] ##   optimality_proven search_state solving_time  mesh_initial          mesh ## 1              TRUE   TERMINATED        0.944 13667.84 [ha] 14232.66 [ha] ##       mesh_best ## 1 14232.66 [ha]"},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Ecological Restoration Planning","text":"Please cite restoptr R package using publications. Justeau‐Allaire, D., Hanson, J. O., Lannuzel, G., Vismara, P., Lorca, X., & Birnbaum, P. (2023). restoptr: R package ecological restoration planning. Restoration Ecology, e13910. https://doi.org/10.1111/rec.13910","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting help","title":"Ecological Restoration Planning","text":"questions using package, suggestions improvements, detect bug, please open issue online code repository. designed package make relatively easy add new functionality, delighted hear .","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"Ecological Restoration Planning","text":"Jaeger, J. . G. (2000). Landscape division, splitting index, effective mesh size: New measures landscape fragmentation. Landscape Ecology, 15(2), 115-‑130. Justeau-Allaire, D., Vieilledent, G., Rinck, N., Vismara, P., Lorca, X., & Birnbaum, P. (2021). Constrained optimization landscape indices conservation planning support ecological restoration New Caledonia. Journal Applied Ecology, 58(4), 744‑-754. Pascual-Hortal, L., & Saura, S. (2006). Comparison development new graph-based landscape connectivity indices: Towards priorization habitat patches corridors conservation. Landscape Ecology, 21(7), 959-‑967. Prud’homme, C., Fages, J.-G., & Lorca, X. (2016). Choco Solver Documentation. {TASC, INRIA Rennes, LINA CNRS UMR 6241, COSLING S..S. Available https://choco-solver.org/.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_available_areas_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add available areas constraint — add_available_areas_constraint","title":"Add available areas constraint — add_available_areas_constraint","text":"Add constraint restoration problem (restopt_problem()) object specify certain planning units can selected restoration activities.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_available_areas_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add available areas constraint — add_available_areas_constraint","text":"","code":"add_available_areas_constraint(problem, data, touches = FALSE)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_available_areas_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add available areas constraint — add_available_areas_constraint","text":"problem restopt_problem() Restoration problem object. data terra::rast()  terra::vect() Either raster object containing binary values hat indicate planning units can selected restoration (.e., cells value equal one available), vector object whose features correspond available areas. touches logical available area data vector, define wether rasterization must include pixels touching polygons. (see terra::rasterize()). Useless data raster data.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_available_areas_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add available areas constraint — add_available_areas_constraint","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_available_areas_constraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add available areas constraint — add_available_areas_constraint","text":"Available areas constraints can used incorporate wide range criteria restoration planning problems. can used account existing land-use practices, feasibility restoration activities, stakeholder preferences. example, available areas constraints can used ensure urban areas selected restoration. Additionally, restoration activities can implemented depending certain conditions -- places landscape slope steep -- available areas constraints used ensure restoration activities prioritized places implemented. Furthermore, stakeholders require solutions prioritize particular places restoration, available areas constraints can also used achieve . See add_locked_out_constraint(), achieve available areas constraint defining areas available restoration. Note: locked constraint available constraints, different input data. Thus, modelling perspective, add_available_areas_constraint() just pre processing layer front add_locked_out_constraint(). print restopt problem available areas constraint, see locked constraint.","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_available_areas_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add available areas constraint — add_available_areas_constraint","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  available <- vect( system.file(\"extdata\", \"accessible_areas.gpkg\", package = \"restoptr\") )  # plot data plot(habitat_data) plot(available, add=TRUE)   # create problem with available areas constraints p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_max_iic_objective() %>%   add_restorable_constraint(     min_restore = 5,     max_restore = 5,   ) %>%   add_available_areas_constraint(available) %>%   add_settings(time_limit = 1)  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            Maximize integral index of connectivity  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 5, max_restore = 5, min_proportion = 1, unit = ha)  #>   -  locked out (data = in memory)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # solve problem s <- solve(p) #> Note: The current solution is the best that the solver could find within the time limit. However, the solver had not enough to prove whether it is optimal or not. Consider increasing the time limit if you need a better solution (solving time = 1.1 s)  # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_compactness_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add constraint to limit compactness — add_compactness_constraint","title":"Add constraint to limit compactness — add_compactness_constraint","text":"Add constraint restoration problem (restopt_problem()) object specify compactness solution.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_compactness_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add constraint to limit compactness — add_compactness_constraint","text":"","code":"add_compactness_constraint(problem, max_diameter, unit = \"m\")"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_compactness_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add constraint to limit compactness — add_compactness_constraint","text":"problem restopt_problem() Restoration problem object. max_diameter numeric Maximum diameter value. unit unit object character can coerced area unit (see unit package), \"cells\" cell width aggregated habitat raster. Corresponds unit maximum diameter. input habitat raster use projected coordinate system, \"cells\" available.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_compactness_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add constraint to limit compactness — add_compactness_constraint","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_compactness_constraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add constraint to limit compactness — add_compactness_constraint","text":"compactness constraint defined according diameter smallest enclosing circle contains center selected planning units restoration (see https://w.wiki/4vfg). unit diameter corresponds either unit available unit package, planning unit width (\"cells\"). Note , computation occurs aggregated cells, max_diameter used different unit \"cells\", rounded closest corresponding number cells. example, diameter 4 cells means 4 cells can found line solution. practice, constraint useful ensure feasibility restoration project, integrate economies scale. Compact restoration areas usually associated lower costs easier management, ensures restoration sites far away (e.g. lower travel costs sites, less areas monitor, etc.).","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_compactness_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add constraint to limit compactness — add_compactness_constraint","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   add_restorable_constraint(     min_restore = 200,     max_restore = 300,   ) %>%   add_compactness_constraint(1800, unit = \"m\")  # plot preprocessed data plot(rast(list(p$data$existing_habitat, p$data$restorable_habitat)), nc = 2)   # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            No optimization objective  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 200, max_restore = 300, min_proportion = 1, unit = ha)  #>   -  compactness (max_diameter = 1800, unit = m)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 0 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # Solve problem s <- solve(p) #> Good news: the solver found 1 solution satisfying the constraints ! (solving time = 0.06 s) # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_components_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add constraint to limit the number of connected components — add_components_constraint","title":"Add constraint to limit the number of connected components — add_components_constraint","text":"Add constraint restoration problem (restopt_problem()) object specify number connected components can present within solution.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_components_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add constraint to limit the number of connected components — add_components_constraint","text":"","code":"add_components_constraint(problem, min_nb_components, max_nb_components)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_components_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add constraint to limit the number of connected components — add_components_constraint","text":"problem restopt_problem() Restoration problem object. min_nb_components integer Minimum number connected components. max_nb_components integer Maximum number connected components.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_components_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add constraint to limit the number of connected components — add_components_constraint","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_components_constraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add constraint to limit the number of connected components — add_components_constraint","text":"connected component spatially continuous set planning units. constraints applies set planning units selected restoration, allows specify minimum maximum number connected components. practice, constraint useful ensure feasibility restoration project, integrate economies scale. Continuous restoration areas (.e. less connected components) usually associated lower costs, ensures restoration sites far away (e.g. lower travel costs sites, less areas monitor, etc.). hand, can useful enforce several disconnected restoration areas ensure hazards (e.g. fire) strike planning units time.","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_components_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add constraint to limit the number of connected components — add_components_constraint","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   add_restorable_constraint(     min_restore = 10,     max_restore = 100,   ) %>%   add_components_constraint(1, 1)  # plot preprocessed data plot(rast(list(p$data$existing_habitat, p$data$restorable_habitat)), nc = 2)   # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            No optimization objective  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 10, max_restore = 100, min_proportion = 1, unit = ha)  #>   -  components (min_nb_components = 1, max_nb_components = 1)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 0 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # Solve problem s <- solve(p) #> Good news: the solver found 1 solution satisfying the constraints ! (solving time = 0.01 s) # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_connected_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add constraint to ensure that the selected planning units for restoration\nare connected. — add_connected_constraint","title":"Add constraint to ensure that the selected planning units for restoration\nare connected. — add_connected_constraint","text":"Add constraint restoration problem (restopt_problem()) object specify selected planning units connected","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_connected_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add constraint to ensure that the selected planning units for restoration\nare connected. — add_connected_constraint","text":"","code":"add_connected_constraint(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_connected_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add constraint to ensure that the selected planning units for restoration\nare connected. — add_connected_constraint","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_connected_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add constraint to ensure that the selected planning units for restoration\nare connected. — add_connected_constraint","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_connected_constraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add constraint to ensure that the selected planning units for restoration\nare connected. — add_connected_constraint","text":"connected area path planning units within area. constraints applies set planning units selected restoration. practice, constraint useful ensure feasibility restoration project, integrate economies scale. Connected restoration areas usually associated lower costs, ensures restoration sites far away (e.g. lower travel costs sites, less areas monitor, etc.). Note constraint relies add_components_constraint(), parameters set enforce exactly one connected component. Also see add_components_constraint add_compactness_constraint.","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_connected_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add constraint to ensure that the selected planning units for restoration\nare connected. — add_connected_constraint","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   add_restorable_constraint(     min_restore = 10,     max_restore = 100,   ) %>%   add_connected_constraint()  # plot preprocessed data plot(rast(list(p$data$existing_habitat, p$data$restorable_habitat)), nc = 2)   # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            No optimization objective  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 10, max_restore = 100, min_proportion = 1, unit = ha)  #>   -  components (min_nb_components = 1, max_nb_components = 1)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 0 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # Solve problem s <- solve(p) #> Good news: the solver found 1 solution satisfying the constraints ! (solving time = 0.01 s) # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_locked_out_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add locked out constraint — add_locked_out_constraint","title":"Add locked out constraint — add_locked_out_constraint","text":"Add constraint restoration problem (restopt_problem()) object specify certain planning units selected restoration activities.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_locked_out_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add locked out constraint — add_locked_out_constraint","text":"","code":"add_locked_out_constraint(problem, data, touches = FALSE)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_locked_out_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add locked out constraint — add_locked_out_constraint","text":"problem restopt_problem() Restoration problem object. data terra::rast()  terra::vect() Either raster object containing binary values hat indicate planning units selected restoration (.e., cells value equal one locked solution), vector object whose features correspond locked areas. See function add_available_areas_constraint() get locked constraint allowed restoration areas. touches logical locked data vector, define wether rasterization must include pixels touching polygons. (see terra::rasterize()). Useless data raster data.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_locked_out_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add locked out constraint — add_locked_out_constraint","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_locked_out_constraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add locked out constraint — add_locked_out_constraint","text":"Locked constraints can used incorporate wide range criteria restoration planning problems. can used account existing land-use practices, feasibility restoration activities, stakeholder preferences. example, locked constraints can used ensure urban areas selected restoration. Additionally, restoration activities can implemented depending certain conditions -- places landscape slope steep -- locked constraints used ensure restoration activities prioritized places implemented. Furthermore, stakeholders require solutions prioritize particular places restoration, locked constraints can also used achieve . See add_available_areas_constraint(), achieve locked constraint defining areas available restoration.","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_locked_out_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add locked out constraint — add_locked_out_constraint","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  locked_out_data <- rast(  system.file(\"extdata\", \"locked_out.tif\", package = \"restoptr\") )  # plot data plot(rast(list(habitat_data, locked_out_data)), nc = 2)   # create problem with locked out constraints p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_max_iic_objective() %>%   add_restorable_constraint(     min_restore = 5,     max_restore = 5,   ) %>%   add_locked_out_constraint(data = locked_out_data) %>%   add_settings(time_limit = 1)  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            Maximize integral index of connectivity  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 5, max_restore = 5, min_proportion = 1, unit = ha)  #>   -  locked out (data = in memory)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # solve problem s <- solve(p) #> Note: The current solution is the best that the solver could find within the time limit. However, the solver had not enough to prove whether it is optimal or not. Consider increasing the time limit if you need a better solution (solving time = 1.03 s)  # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_iic_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add constraint to enforce a minimum integral index of connectivity (IIC) value — add_min_iic_constraint","title":"Add constraint to enforce a minimum integral index of connectivity (IIC) value — add_min_iic_constraint","text":"Add constraint restoration problem (restopt_problem()) object specify minimum integral index connectivity solution.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_iic_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add constraint to enforce a minimum integral index of connectivity (IIC) value — add_min_iic_constraint","text":"","code":"add_min_iic_constraint(   problem,   min_iic,   distance_threshold = -1,   unit = \"m\",   precision = 4 )"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_iic_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add constraint to enforce a minimum integral index of connectivity (IIC) value — add_min_iic_constraint","text":"problem restopt_problem() Restoration problem object. min_iic numeric Minimum IIC value (0 1). distance_threshold numeric greater 0. Minimum distance (unit) two patches consider connected computation IIC. default value -1 causes function use 1 aggregated cell distance threshold. unit unit object character can coerced distance unit (see unit package), \"cells\" cell width aggregated habitat raster. Units distance_threshold parameter. input habitat raster use projected coordinate system, \"cells\" available. Meters default, expected distance_threshold set default value (-1), causes function use 1 cell default. precision integer Precision calculations. Defaults 4.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_iic_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add constraint to enforce a minimum integral index of connectivity (IIC) value — add_min_iic_constraint","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_iic_constraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add constraint to enforce a minimum integral index of connectivity (IIC) value — add_min_iic_constraint","text":"integral index connectivity (IIC) graph-based inter-patch connectivity index based binary connection model (Pascual-Hortal & Saura, 2006). maximization context restoration favours restoring structural connectivity large patches. IIC unitless comprised 0 (connectivity) 1 (landscape habitat, thus fully connected). distance_threshold parameter indicates solver construct habitat graph, .e. minimum distance two patches consider connected. Note , computation occurs aggregated cells, distance_threshold used different unit \"cells\", rounded closest corresponding number cells. effective mesh size (MESH) measure landscape fragmentation based probability two randomly chosen points located patch (Jaeger, 2000). Maximizing context restoration favours fewer larger patches.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_iic_constraint.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add constraint to enforce a minimum integral index of connectivity (IIC) value — add_min_iic_constraint","text":"Pascual-Hortal, L., & Saura, S. (2006). Comparison development new graph-based landscape connectivity indices: Towards priorization habitat patches corridors conservation. Landscape Ecology, 21(7), 959‑967. https://doi.org/10.1007/s10980-006-0013-z","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_iic_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add constraint to enforce a minimum integral index of connectivity (IIC) value — add_min_iic_constraint","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  locked_out_data <- rast(  system.file(\"extdata\", \"locked_out.tif\", package = \"restoptr\") )  # create problem with locked out constraints p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   add_min_iic_constraint(0.2) %>%   add_restorable_constraint(     min_restore = 200,     max_restore = 300,   ) %>%   add_locked_out_constraint(data = locked_out_data) %>%   add_compactness_constraint(2500, unit = \"m\") %>%   add_settings(time_limit = 1)  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            No optimization objective  #> -----------------------------------------------------------------  #> constraints:           #>   -  min IIC (min_iic = 0.2, distance_threshold = 1, unit = cells, precision = 4)  #>   -  restorable (min_restore = 200, max_restore = 300, min_proportion = 1, unit = ha)  #>   -  locked out (data = in memory)  #>   -  compactness (max_diameter = 2500, unit = m)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # solve problem s <- solve(p) #> Good news: the solver found 1 solution satisfying the constraints ! (solving time = 0.31 s)  # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_mesh_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add constraint to enforce a minimum effective mesh size (MESH) value — add_min_mesh_constraint","title":"Add constraint to enforce a minimum effective mesh size (MESH) value — add_min_mesh_constraint","text":"Add constraint restoration problem (restopt_problem()) object specify minimum effective mesh size solution.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_mesh_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add constraint to enforce a minimum effective mesh size (MESH) value — add_min_mesh_constraint","text":"","code":"add_min_mesh_constraint(problem, min_mesh, precision = 4, unit = \"ha\")"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_mesh_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add constraint to enforce a minimum effective mesh size (MESH) value — add_min_mesh_constraint","text":"problem restopt_problem() Restoration problem object. min_mesh numeric Minimum MESH value. precision integer Precision calculations. Defaults 4. unit unit object character can coerced area unit (see unit package), \"cells\" cell width aggregated habitat raster. Corresponds unit minimum mesh value input habitat raster use projected coordinate system, \"cells\" available. Defaults \"ha\".","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_mesh_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add constraint to enforce a minimum effective mesh size (MESH) value — add_min_mesh_constraint","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_mesh_constraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add constraint to enforce a minimum effective mesh size (MESH) value — add_min_mesh_constraint","text":"effective mesh size (MESH) measure landscape fragmentation based probability two randomly chosen points located patch (Jaeger, 2000). Maximizing context restoration favours fewer larger patches.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_mesh_constraint.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Add constraint to enforce a minimum effective mesh size (MESH) value — add_min_mesh_constraint","text":"Jaeger, J. . G. (2000). Landscape division, splitting index, effective mesh size: New measures landscape fragmentation. Landscape Ecology, 15(2), 115‑130. https://doi.org/10.1023/:1008129329289","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_min_mesh_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add constraint to enforce a minimum effective mesh size (MESH) value — add_min_mesh_constraint","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   add_restorable_constraint(     min_restore = 200,     max_restore = 300,   ) %>%   add_min_mesh_constraint(min_mesh = 2500, unit = \"ha\")  # plot preprocessed data plot(rast(list(p$data$existing_habitat, p$data$restorable_habitat)), nc = 2)   # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            No optimization objective  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 200, max_restore = 300, min_proportion = 1, unit = ha)  #>   -  min MESH (min_mesh = 2500, precision = 4, unit = ha)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 0 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # Solve problem s <- solve(p) #> Good news: the solver found 1 solution satisfying the constraints ! (solving time = 0.01 s) # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_restorable_constraint.html","id":null,"dir":"Reference","previous_headings":"","what":"Add constraint to specify the available amount of surface for restoration — add_restorable_constraint","title":"Add constraint to specify the available amount of surface for restoration — add_restorable_constraint","text":"Add constraint restoration problem (restopt_problem()) object specify specify available amount surface restoration","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_restorable_constraint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add constraint to specify the available amount of surface for restoration — add_restorable_constraint","text":"","code":"add_restorable_constraint(   problem,   min_restore,   max_restore,   min_proportion = 1,   unit = \"ha\" )"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_restorable_constraint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add constraint to specify the available amount of surface for restoration — add_restorable_constraint","text":"problem restopt_problem() Restoration problem object. min_restore numeric Minimum allowed area restore solution. max_restore numeric Maximum allowed area restore solution min_proportion float Minimum habitat proportion consider cell restored. unit unit object character can coerced area unit (see unit package), \"cells\" number cells original habitat raster). input habitat raster use projected coordinate system, \"cells\" available.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_restorable_constraint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add constraint to specify the available amount of surface for restoration — add_restorable_constraint","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_restorable_constraint.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add constraint to specify the available amount of surface for restoration — add_restorable_constraint","text":"Given restorable_habitat input raster restopt_problem, constraint ensures total amount restorable habitat selected planning units least min_restore max_restore. unit min_restore max_restore can either surface unit handled unit package, number cells original habitat input raster (\"cells\"). min_proportion parameter numeric 0 1, correspond minimum proportion habitat area needs restored planning unit consider planning unit restored. proportion relative area planning unit, computed automatically input habitat raster. Note planning unit area considered uniform, distortion corrected. using cellSize function terra package, function currently pretty slow large rasters. problem regional scale, distortion negligible. However, larger scales, best use equal-area projected coordinate system. Note solution found, \"maximum restorable habitat\" displayed, value correspond max_restore parameter, total area can restored selected planning units. max_restore parameter actually upper bound minimum habitat needs restored reach min_proportion habitat every selected planning units.","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_restorable_constraint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add constraint to specify the available amount of surface for restoration — add_restorable_constraint","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   add_restorable_constraint(     min_restore = 200,     max_restore = 300,     min_proportion = 0.7   ) %>%   add_compactness_constraint(5, unit = \"cells\")  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            No optimization objective  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 200, max_restore = 300, min_proportion = 0.7, unit = ha)  #>   -  compactness (max_diameter = 5, unit = cells)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 0 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # plot preprocessed data plot(rast(list(get_existing_habitat(p),                get_restorable_habitat(p),                get_locked_out_areas(p))), nc = 3)   # Solve problem s <- solve(p) #> Good news: the solver found 1 solution satisfying the constraints ! (solving time = 0.07 s) # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_settings.html","id":null,"dir":"Reference","previous_headings":"","what":"Add settings — add_settings","title":"Add settings — add_settings","text":"Add settings restoration problem (restopt_problem()) object customize optimization procedure.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_settings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add settings — add_settings","text":"","code":"add_settings(   problem,   precision = 4,   time_limit = 0,   nb_solutions = 1,   optimality_gap = 0,   solution_name_prefix = \"Solution \" )"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_settings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add settings — add_settings","text":"problem restopt_problem() Restoration problem object. precision integer Precision calculations. Defaults 4. time_limit integer Maximum permitted run time optimization (seconds). Defaults 0. nb_solutions integer Number desired solutions. Defaults 1. optimality_gap numeric Optimality gap (0 1). example, argument 0.1 means solutions within 10% optimality. Defaults 0, optimal solutions returned. solution_name_prefix character Prefix name solutions. Defaults \"Solution \"","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_settings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add settings — add_settings","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/add_settings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add settings — add_settings","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   add_settings(time_limit = 1, precision = 4, nb_solutions = 2) # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            No optimization objective  #> -----------------------------------------------------------------  #> constraints:         none defined  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 2 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/area_to_nb_cells.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the number of cells corresponding to a given area. — area_to_nb_cells","title":"Compute the number of cells corresponding to a given area. — area_to_nb_cells","text":"Compute number cells corresponding given area.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/area_to_nb_cells.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the number of cells corresponding to a given area. — area_to_nb_cells","text":"","code":"area_to_nb_cells(raster_layer, area, unit = \"ha\")"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/area_to_nb_cells.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the number of cells corresponding to a given area. — area_to_nb_cells","text":"raster_layer terra::rast() Raster object. area numeric Area. unit unit object character can coerced unit (see unit package). Must area unit.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/area_to_nb_cells.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the number of cells corresponding to a given area. — area_to_nb_cells","text":"numeric number raster cell correspond given area.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/area_to_nb_cells.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the number of cells corresponding to a given area. — area_to_nb_cells","text":"input raster must projected coordinate system. distortion corrected. using cellSize function terra package, function currently pretty slow large rasters. problem regional scale, distortion negligible. However, larger scales, best use equal-area projected coordinate system.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/area_to_nb_cells.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the number of cells corresponding to a given area. — area_to_nb_cells","text":"","code":"# \\donttest{ habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") ) area_to_nb_cells(habitat_data, 20, unit = \"ha\") #> 240.5902 [1/ha] # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_area.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the area of a cell — cell_area","title":"Compute the area of a cell — cell_area","text":"Compute area cell","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the area of a cell — cell_area","text":"","code":"cell_area(raster_layer, unit = \"ha\")"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the area of a cell — cell_area","text":"raster_layer terra::rast() Raster object. unit unit object character can coerced unit (see unit package). Must area unit.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the area of a cell — cell_area","text":"numeric area cell desired unit.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_area.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the area of a cell — cell_area","text":"input raster must projected coordinate system. distortion corrected. using cellSize function terra package, function currently pretty slow large rasters. problem regional scale, distortion negligible. However, larger scales, best use equal-area projected coordinate system.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the area of a cell — cell_area","text":"","code":"# \\donttest{ habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") ) cell_area(habitat_data, \"ha\") #> 0.08312891 [ha] # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_width.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the width of a cell — cell_width","title":"Compute the width of a cell — cell_width","text":"Compute width cell","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_width.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the width of a cell — cell_width","text":"","code":"cell_width(raster_layer, unit = \"m\")"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_width.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the width of a cell — cell_width","text":"raster_layer terra::rast() Raster object. unit unit object character can coerced unit (see unit package). Must length unit.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_width.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the width of a cell — cell_width","text":"numeric width cell desired unit.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_width.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the width of a cell — cell_width","text":"input raster must projected coordinate system. distortion corrected. using cellSize function terra package, function currently pretty slow large rasters. problem regional scale, distortion negligible. However, larger scales, best use equal-area projected coordinate system.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/cell_width.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the width of a cell — cell_width","text":"","code":"# \\donttest{ habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") ) cell_width(habitat_data, \"m\") #> 27.9487 [m] # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_aggregation_factor.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the aggregation factor of a restopt problem. — get_aggregation_factor","title":"Retrieve the aggregation factor of a restopt problem. — get_aggregation_factor","text":"Retrieve aggregation factor restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_aggregation_factor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the aggregation factor of a restopt problem. — get_aggregation_factor","text":"","code":"get_aggregation_factor(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_aggregation_factor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the aggregation factor of a restopt problem. — get_aggregation_factor","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_aggregation_factor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the aggregation factor of a restopt problem. — get_aggregation_factor","text":"numeric aggregation factor restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_aggregation_factor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the aggregation factor of a restopt problem. — get_aggregation_factor","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem problem <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  get_aggregation_factor(problem) #> [1] 4 # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_cell_area.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the aggregated cell area of a restopt problem. — get_cell_area","title":"Retrieve the aggregated cell area of a restopt problem. — get_cell_area","text":"Retrieve aggregated cell area restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_cell_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the aggregated cell area of a restopt problem. — get_cell_area","text":"","code":"get_cell_area(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_cell_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the aggregated cell area of a restopt problem. — get_cell_area","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_cell_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the aggregated cell area of a restopt problem. — get_cell_area","text":"terra::rast() aggregated cell area restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_cell_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the aggregated cell area of a restopt problem. — get_cell_area","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem problem <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  get_cell_area(problem) #> class       : SpatRaster  #> dimensions  : 467, 679, 1  (nrow, ncol, nlyr) #> resolution  : 111.7948, 118.9736  (x, y) #> extent      : 419768.2, 495676.9, 227509.1, 283069.8  (xmin, xmax, ymin, ymax) #> coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  #> source(s)   : memory #> name        : Cell area (aggregated)  #> min value   :                      1  #> max value   :                     16  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_constraints.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the constraints of a restopt problem. — get_constraints","title":"Retrieve the constraints of a restopt problem. — get_constraints","text":"Retrieve constraints restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_constraints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the constraints of a restopt problem. — get_constraints","text":"","code":"get_constraints(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_constraints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the constraints of a restopt problem. — get_constraints","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_constraints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the constraints of a restopt problem. — get_constraints","text":"list constraints restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_constraints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the constraints of a restopt problem. — get_constraints","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem problem <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  get_constraints(problem) #> list() # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_existing_habitat.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the existing (i.e. aggregated) habitat data. — get_existing_habitat","title":"Retrieve the existing (i.e. aggregated) habitat data. — get_existing_habitat","text":"Retrieve existing (.e. aggregated) habitat data.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_existing_habitat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the existing (i.e. aggregated) habitat data. — get_existing_habitat","text":"","code":"get_existing_habitat(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_existing_habitat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the existing (i.e. aggregated) habitat data. — get_existing_habitat","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_existing_habitat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the existing (i.e. aggregated) habitat data. — get_existing_habitat","text":"terra::rast() existing (aggregated) habitat data.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_existing_habitat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the existing (i.e. aggregated) habitat data. — get_existing_habitat","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem problem <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  plot(get_existing_habitat(problem))  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_habitat_threshold.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the habitat threshold parameter of a restopt problem. — get_habitat_threshold","title":"Retrieve the habitat threshold parameter of a restopt problem. — get_habitat_threshold","text":"Retrieve habitat threshold parameter restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_habitat_threshold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the habitat threshold parameter of a restopt problem. — get_habitat_threshold","text":"","code":"get_habitat_threshold(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_habitat_threshold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the habitat threshold parameter of a restopt problem. — get_habitat_threshold","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_habitat_threshold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the habitat threshold parameter of a restopt problem. — get_habitat_threshold","text":"numeric habitat threshold parameter restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_habitat_threshold.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the habitat threshold parameter of a restopt problem. — get_habitat_threshold","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem problem <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  get_habitat_threshold(problem) #> [1] 0.7 # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_locked_out_areas.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the locked out areas of a restopt problem. — get_locked_out_areas","title":"Retrieve the locked out areas of a restopt problem. — get_locked_out_areas","text":"Retrieve locked areas restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_locked_out_areas.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the locked out areas of a restopt problem. — get_locked_out_areas","text":"","code":"get_locked_out_areas(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_locked_out_areas.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the locked out areas of a restopt problem. — get_locked_out_areas","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_locked_out_areas.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the locked out areas of a restopt problem. — get_locked_out_areas","text":"terra::rast() locked areas restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_locked_out_areas.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the locked out areas of a restopt problem. — get_locked_out_areas","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem problem <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  get_locked_out_areas(problem) #> class       : SpatRaster  #> dimensions  : 467, 679, 1  (nrow, ncol, nlyr) #> resolution  : 111.7948, 118.9736  (x, y) #> extent      : 419768.2, 495676.9, 227509.1, 283069.8  (xmin, xmax, ymin, ymax) #> coord. ref. : RGNC91-93 / Lambert New Caledonia (EPSG:3163)  #> source(s)   : memory #> name        : Restorable habitat (aggregated)  #> min value   :                               0  #> max value   :                               1  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Restopt solution metadata — get_metadata","title":"Restopt solution metadata — get_metadata","text":"Return metadata associated restopt solution, contains characteristics solution. unit area characteristics can chosen among \"ha\" (hectares), \"m\" (square meters), \"km\" (square kilometers), \"cells\" (cells original input habitat raster). Note solving time expressed seconds.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restopt solution metadata — get_metadata","text":"","code":"get_metadata(restopt_solution, area_unit = \"ha\", distance_unit = \"m\")"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restopt solution metadata — get_metadata","text":"restopt_solution restopt_solution() Restopt solution solution. area_unit unit object character can coerced area unit (see unit package), \"cells\" number cells original habitat raster). Unit areas. input habitat raster use projected coordinate system, \"cells\" available. Default \"ha\" distance_unit unit object character can coerced area unit (see unit package), \"cells\" number cell width original habitat raster). Unit distances. input habitat raster use projected coordinate system, \"cells\" available. Default \"m\"","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restopt solution metadata — get_metadata","text":"list containing characteristics restopt solution.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the optimization objective of a restopt problem. — get_objective","title":"Retrieve the optimization objective of a restopt problem. — get_objective","text":"Retrieve optimization objective restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the optimization objective of a restopt problem. — get_objective","text":"","code":"get_objective(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the optimization objective of a restopt problem. — get_objective","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the optimization objective of a restopt problem. — get_objective","text":"RestoptObjectve optimization objective restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the optimization objective of a restopt problem. — get_objective","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem problem <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  get_objective(problem) #> $name #> [1] \"No optimization objective\" #>  #> $post #> function (jproblem, nb_solutions, precision, time_limit, optimality_gap,  #>     verbose = FALSE, search_strategy = \"\")  #> { #>     rJava::.jcall(jproblem, \"Ljava/util/List;\", \"findSolutions\",  #>         nb_solutions, time_limit, verbose, search_strategy) #> } #> <bytecode: 0x5555edc90348> #> <environment: 0x5555efb25900> #>  #> attr(,\"class\") #> [1] \"NoObjective\"      \"RestoptObjectve\"  \"RestoptComponent\" # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_original_habitat.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the original (i.e. not aggregated) habitat data. — get_original_habitat","title":"Retrieve the original (i.e. not aggregated) habitat data. — get_original_habitat","text":"Retrieve original (.e. aggregated) habitat data.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_original_habitat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the original (i.e. not aggregated) habitat data. — get_original_habitat","text":"","code":"get_original_habitat(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_original_habitat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the original (i.e. not aggregated) habitat data. — get_original_habitat","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_original_habitat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the original (i.e. not aggregated) habitat data. — get_original_habitat","text":"terra::rast() original (.e. aggregated) habitat data.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_original_habitat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the original (i.e. not aggregated) habitat data. — get_original_habitat","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem problem <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  plot(get_original_habitat(problem))  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_restorable_habitat.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the restorable habitat (aggregated) data. — get_restorable_habitat","title":"Retrieve the restorable habitat (aggregated) data. — get_restorable_habitat","text":"Retrieve restorable habitat (aggregated) data.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_restorable_habitat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the restorable habitat (aggregated) data. — get_restorable_habitat","text":"","code":"get_restorable_habitat(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_restorable_habitat.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the restorable habitat (aggregated) data. — get_restorable_habitat","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_restorable_habitat.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the restorable habitat (aggregated) data. — get_restorable_habitat","text":"terra::rast() restorable habitat (aggregated) data.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_restorable_habitat.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the restorable habitat (aggregated) data. — get_restorable_habitat","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem problem <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  plot(get_restorable_habitat(problem))  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_settings.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve the settings of a restopt problem. — get_settings","title":"Retrieve the settings of a restopt problem. — get_settings","text":"Retrieve settings restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_settings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve the settings of a restopt problem. — get_settings","text":"","code":"get_settings(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_settings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve the settings of a restopt problem. — get_settings","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_settings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve the settings of a restopt problem. — get_settings","text":"list settings associated restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/get_settings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve the settings of a restopt problem. — get_settings","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem problem <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  get_settings(problem) #> $precision #> [1] 4 #>  #> $time_limit #> [1] 0 #>  #> $nb_solutions #> [1] 1 #>  #> $optimality_gap #> [1] 0 #>  #> $solution_name_prefix #> [1] \"Solution \" #>  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/invert_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Invert a vector layer according to the extent of a restopt problem. — invert_vector","title":"Invert a vector layer according to the extent of a restopt problem. — invert_vector","text":"Invert vector layer according extent restopt problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/invert_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Invert a vector layer according to the extent of a restopt problem. — invert_vector","text":"","code":"invert_vector(vector_layer, extent = NULL, filter = NULL)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/invert_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Invert a vector layer according to the extent of a restopt problem. — invert_vector","text":"vector_layer terra::vect() Vector layer. extent SpatExtent Optional: can specify another extent input vector layer extent inversion. filter Optional: filter apply x. Leave NULL filtering.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/invert_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Invert a vector layer according to the extent of a restopt problem. — invert_vector","text":"terra::vect() Vector object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/invert_vector.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Invert a vector layer according to the extent of a restopt problem. — invert_vector","text":"Invert vector layer according extent, user-specified extent. function useful derive locked areas accessible areas, e.g. buffer around tracks.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/invert_vector.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Invert a vector layer according to the extent of a restopt problem. — invert_vector","text":"","code":"# \\donttest{ habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") ) available <- vect(   system.file(\"extdata\", \"accessible_areas.gpkg\", package = \"restoptr\") ) locked_out <- invert_vector(   vector_layer = available,   extent = ext(habitat_data),   filter = available$ID==2 ) # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/is_java_available.html","id":null,"dir":"Reference","previous_headings":"","what":"Is Java is available? — is_java_available","title":"Is Java is available? — is_java_available","text":"restoptr package uses Java perform optimization procedures. , important Java installed correctly using package. function verifies Java available system.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/is_java_available.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is Java is available? — is_java_available","text":"","code":"is_java_available()"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/is_java_available.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is Java is available? — is_java_available","text":"logical (TRUE FALSE) value indicating Java available usage.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/nb_cell_to_area.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute the area corresponding to a given number of cells. — nb_cell_to_area","title":"Compute the area corresponding to a given number of cells. — nb_cell_to_area","text":"Compute area corresponding given number cells.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/nb_cell_to_area.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute the area corresponding to a given number of cells. — nb_cell_to_area","text":"","code":"nb_cell_to_area(raster_layer, nb_cells, unit = \"ha\")"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/nb_cell_to_area.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute the area corresponding to a given number of cells. — nb_cell_to_area","text":"raster_layer terra::rast() Raster object. nb_cells numeric Number raster cells. unit unit object character can coerced unit (see unit package). Must area unit.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/nb_cell_to_area.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute the area corresponding to a given number of cells. — nb_cell_to_area","text":"numeric area corresponding nb_cells desired unit.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/nb_cell_to_area.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute the area corresponding to a given number of cells. — nb_cell_to_area","text":"input raster must projected coordinate system. distortion corrected. using cellSize function terra package, function currently pretty slow large rasters. problem regional scale, distortion negligible. However, larger scales, best use equal-area projected coordinate system.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/nb_cell_to_area.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute the area corresponding to a given number of cells. — nb_cell_to_area","text":"","code":"# \\donttest{ habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") ) nb_cell_to_area(habitat_data, 20, unit = \"ha\") #> 1.662578 [ha] # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/pipe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pipe operator — %>%","text":"lhs value magrittr placeholder. rhs function call using magrittr semantics.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/pipe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pipe operator — %>%","text":"result calling rhs(lhs).","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/preprocess_input.html","id":null,"dir":"Reference","previous_headings":"","what":"Restopr input preprocessing function. — preprocess_input","title":"Restopr input preprocessing function. — preprocess_input","text":"binary, possibly high resolution, habitat raster, function produces three input rasters restopt:","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/preprocess_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restopr input preprocessing function. — preprocess_input","text":"","code":"preprocess_input(habitat, habitat_threshold = 1, aggregation_factor = 1)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/preprocess_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restopr input preprocessing function. — preprocess_input","text":"habitat terra::rast() Raster object containing binary values indicate planning unit contains habitat . Cells value 1 must correspond existing habitat. Cells value 0 must correspond degraded (simply non-habitat) areas. Finally, NA (NO_DATA) cells considered outside landscape. habitat_threshold numeric Number 0 1 indicating, habitat raster downsampled, minimum proportion habitat cells (original raster) required within downsampled raster considered habitat. aggregation_factor integer positive integer corresponding level downsampling applied habitat. parameter important ensure tractability problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/preprocess_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restopr input preprocessing function. — preprocess_input","text":"list : list( existing_habitat=downsampled_habitat, restorable_habitat=restorable_habitat, cell_area=cell_area )","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/preprocess_input.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Restopr input preprocessing function. — preprocess_input","text":"binary habitat raster (existing_habitat), can input (aggregation factor = 1), often downsampled version , ensure tractability problem. restorable habitat raster (restorable_habitat), raster indicating much habitat can restored. aggregation factor = 1, restorable habitat raster binary inverse habitat raster. Else, surface habitat computed according spatial resolution, number habitat pixel present one larger aggregated cell. cell area raster (cell_area), correspond aggregated cell number number cells input raster. necessary cell area can less expected aggregated cell lies boundary study area. preprocessing function produces necessary inputs restopt problem single binary habitat raster (habitat), can high resolution. Restopt solves hard constrained combinatorial problem (can reduced constrained 0/1 knapsack problem, know NP-Complete), thus input resolution might need reduced ensure tractable problem. Performing downsampling systematic reproducible way aim function, relies terra::aggregate() function . aggregation_factor parameter indicates much resolution must reduced. aggregated pixel contain aggregation_factor^2 pixels input habitat raster (cell_area raster function outputs). aggregated pixel close spatial boundaries problem (.e. NA cells), can contain less aggregation_factor^2 fine grained pixels. habitat_threshold parameter indicates minimum proportion habitat pixels (relative cell_area) whose value 1 consider aggregated pixel habitat (downsampled_habitat output raster). restorable_area output raster correspond number pixel value 0 aggregated pixels.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/preprocess_input.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restopr input preprocessing function. — preprocess_input","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\")) data <- preprocess_input(     habitat = habitat_data,     habitat_threshold = 0.7,     aggregation_factor = 16 ) # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/print.RestoptProblem.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a restoration optimization problem — print.RestoptProblem","title":"Print a restoration optimization problem — print.RestoptProblem","text":"Display information restoration optimization problem.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/print.RestoptProblem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a restoration optimization problem — print.RestoptProblem","text":"","code":"# S3 method for RestoptProblem print(x, ...)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/print.RestoptProblem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a restoration optimization problem — print.RestoptProblem","text":"x restopt_problem() Restoration problem object. ... Arguments used.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/print.RestoptProblem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print a restoration optimization problem — print.RestoptProblem","text":"","code":"# \\donttest{ #' # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem p <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   4  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            No optimization objective  #> -----------------------------------------------------------------  #> constraints:         none defined  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 0 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restopt_problem.html","id":null,"dir":"Reference","previous_headings":"","what":"Restoration optimization problem — restopt_problem","title":"Restoration optimization problem — restopt_problem","text":"Create new restoration optimization problem (RestoptProblem) using data describe spatial distribution existing habitat (potentially high resolution), parameters derive downsampled existing habitat raster, suitable tractable optimization, restorable habitat raster. Constraints can added restopt problem using add_****_constraint() functions, optimization objective can set using set_****_objective() functions.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restopt_problem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restoration optimization problem — restopt_problem","text":"","code":"restopt_problem(   existing_habitat,   habitat_threshold = 1,   aggregation_factor = 1 )"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restopt_problem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restoration optimization problem — restopt_problem","text":"existing_habitat terra::rast() Raster object containing binary values indicate planning unit contains habitat . Cells value 1 must correspond existing habitat. Cells value 0 must correspond degraded (simply non-habitat) areas. Finally, NA (NO_DATA) cells considered outside landscape. raster can high resolution, aggregation_factor habitat_threshold parameters, described , used sample habitat raster tractable resolution optimization engine, automatically derive restorable habitat raster. habitat_threshold numeric number 0 1, corresponds minimum proportion habitat must present within aggregated pixel consider habitat pixel. aggregation_factor integer Integer greater 1, corresponds aggregation factor sampling data. example, aggregation_factor = 2, aggregated pixel contain 4 original pixel. See terra::aggregate() details.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restopt_problem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restoration optimization problem — restopt_problem","text":"new restoration problem (RestoptProblem) object. None.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restopt_problem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Restoration optimization problem — restopt_problem","text":"function creates base restoration optimization problem object, can extended constraints optimization objectives. One input rasters necessary instantiate restopt problem: existing_habitat raster (potentially high resolution). raster must contains data habitat areas (raster value 1), non-habitat areas (raster value 0), areas must considered solving procedure (NA NO_DATA). aggregation_factor parameter used sample existing_habitat resolution tractable optimization engine, habitat_threshold parameter indicates minimum proportion habitat required aggregated habitat pixels consider habitat. Note aggregated pixel contain aggregation_factor^2 pixels input habitat raster (cell_area raster function outputs). aggregated pixel close spatial boundaries problem (.e. NA cells), can contain less aggregation_factor^2 fine grained pixel. can get results preprocessing phase using following methods: get_original_habitat() (original habitat), get_existing_habitat() (aggregated habitat), get_cell_area() (number pixels aggregated cells), get_restorable_area() (amount restorable area -- number original raster pixels).","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restopt_problem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Restoration optimization problem — restopt_problem","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem p <- restopt_problem(        existing_habitat = habitat_data,        aggregation_factor = 4,        habitat_threshold = 0.7 )  # Plot down sampled data plot(c(p$data$existing_habitat, p$data$restorable_habitat))   # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   4  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            No optimization objective  #> -----------------------------------------------------------------  #> constraints:         none defined  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 0 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restopt_solution.html","id":null,"dir":"Reference","previous_headings":"","what":"Restopt solution — restopt_solution","title":"Restopt solution — restopt_solution","text":"object representing restopt problem solution. basically SpatRaster metadata attributes added.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restopt_solution.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Restopt solution — restopt_solution","text":"","code":"restopt_solution(restopt_problem, solution_raster, metadata, id_solution = 1)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restopt_solution.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Restopt solution — restopt_solution","text":"restopt_problem restopt_problem() Reference problem corresponding solution. solution_raster terra::rast() Solution raster. metadata list List containing metadata attributes solution. id_solution integer Identifier solution.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restopt_solution.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Restopt solution — restopt_solution","text":"new restoration problem solution (restopt_solution()).","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restoptr.html","id":null,"dir":"Reference","previous_headings":"","what":"restoptr: Ecological Restoration Planning — restoptr","title":"restoptr: Ecological Restoration Planning — restoptr","text":"restoptr package relies Constraint Programming (CP) build solve ecological restoration planning problems. restoptr problem starts existing habitat (raster), aim identify optimal areas suitable restoration. Several constraints available define expected suitable area (e.g. must connected, compact, must respect budget, etc). Several optimization objective also available define good restoration area (e.g. must reduce fragmentation, increase ecological connectivity, minimize costs, etc.). restoptr relies advanced landscape indices effective mesh size (Jaeger, 2000), integral index connectivity (Pascual-Hortal & Saura, 2006) address complex restoration planning problems.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restoptr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"restoptr: Ecological Restoration Planning — restoptr","text":"restoptr relies Choco-solver (https://choco-solver.org/), open-source Java CP solver (Prud'homme et al., 2017). computationally intensive solving part thus delegated Java (see restopt, https://github.com/dimitri-justeau/restopt), communication R Java handled rJava package. Therefore, Java Runtime Environment (>= 8) necessary use restopt. Note methodology used restoptr first described Justeau-Allaire et al. (2021), restoptr provides much flexibility, new features (e.g. reliable consistent data preprocessing), new constraints, new optimization objectives, improved computational efficiency. Also note API inspired prioritizr package. package contains several vignettes detail usage showcase features. can explore vignettes using browseVignettes(\"restoptr\")","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/restoptr.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"restoptr: Ecological Restoration Planning — restoptr","text":"Hanson JO, Schuster R, Morrell N, Strimas-Mackey M, Edwards BPM, Watts , Arcese P, Bennett J, Possingham HP (2022). prioritizr: Systematic Conservation Prioritization R. R package version 7.1.1. Available https://CRAN.R-project.org/package=prioritizr. Jaeger, J. . G. (2000). Landscape division, splitting index, effective mesh size: New measures landscape fragmentation. Landscape Ecology, 15(2), 115‑130. Justeau-Allaire, D., Vieilledent, G., Rinck, N., Vismara, P., Lorca, X., & Birnbaum, P. (2021). Constrained optimization landscape indices conservation planning support ecological restoration New Caledonia. Journal Applied Ecology, 58(4), 744‑754. Pascual-Hortal, L., & Saura, S. (2006). Comparison development new graph-based landscape connectivity indices: Towards priorization habitat patches corridors conservation. Landscape Ecology, 21(7), 959‑967. Prud'homme, C., Fages, J.-G., & Lorca, X. (2017). Choco documentation.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_iic_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Set an objective to maximize the integral index of connectivity — set_max_iic_objective","title":"Set an objective to maximize the integral index of connectivity — set_max_iic_objective","text":"Specify restoration problem (restopt_problem()) integral index connectivity (IIC).","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_iic_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set an objective to maximize the integral index of connectivity — set_max_iic_objective","text":"","code":"set_max_iic_objective(problem, distance_threshold = -1, unit = \"m\")"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_iic_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set an objective to maximize the integral index of connectivity — set_max_iic_objective","text":"problem restopt_problem() Restoration problem object. distance_threshold numeric greater 0. Minimum distance (unit) two patches consider connected computation IIC. default value -1 causes function use 1 aggregated cell distance threshold. unit unit object character can coerced distance unit (see unit package), \"cells\" cell width aggregated habitat raster. Units distance_threshold parameter. input habitat raster use projected coordinate system, \"cells\" available. Meters default, expected distance_threshold set default value (-1), causes function use 1 cell default.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_iic_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set an objective to maximize the integral index of connectivity — set_max_iic_objective","text":"updated restoration problem (restopt_problem() object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_iic_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set an objective to maximize the integral index of connectivity — set_max_iic_objective","text":"integral index connectivity (IIC) graph-based inter-patch connectivity index based binary connection model (Pascual-Hortal & Saura, 2006). maximization context restoration favours restoring structural connectivity large patches. IIC unitless comprised 0 (connectivity) 1 (landscape habitat, thus fully connected). distance_threshold parameter indicates solver construct habitat graph, .e. minimum distance two patches consider connected. Note , computation occurs aggregated cells, distance_threshold used different unit \"cells\", rounded closest corresponding number cells.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_iic_objective.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Set an objective to maximize the integral index of connectivity — set_max_iic_objective","text":"Pascual-Hortal, L., & Saura, S. (2006). Comparison development new graph-based landscape connectivity indices: Towards priorization habitat patches corridors conservation. Landscape Ecology, 21(7), 959‑967. https://doi.org/10.1007/s10980-006-0013-z","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_iic_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set an objective to maximize the integral index of connectivity — set_max_iic_objective","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  locked_out_data <- rast(  system.file(\"extdata\", \"locked_out.tif\", package = \"restoptr\") )  # create problem with locked out constraints p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_max_iic_objective() %>%   add_restorable_constraint(     min_restore = 5,     max_restore = 5,   ) %>%   add_locked_out_constraint(data = locked_out_data) %>%   add_settings(time_limit = 1)  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            Maximize integral index of connectivity  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 5, max_restore = 5, min_proportion = 1, unit = ha)  #>   -  locked out (data = in memory)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # solve problem s <- solve(p) #> Note: The current solution is the best that the solver could find within the time limit. However, the solver had not enough to prove whether it is optimal or not. Consider increasing the time limit if you need a better solution (solving time = 1.01 s)  # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_mesh_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Set an objective to maximize effective mesh size — set_max_mesh_objective","title":"Set an objective to maximize effective mesh size — set_max_mesh_objective","text":"Specify restoration problem (restopt_problem()) maximize effective mesh size.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_mesh_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set an objective to maximize effective mesh size — set_max_mesh_objective","text":"","code":"set_max_mesh_objective(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_mesh_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set an objective to maximize effective mesh size — set_max_mesh_objective","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_mesh_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set an objective to maximize effective mesh size — set_max_mesh_objective","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_mesh_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set an objective to maximize effective mesh size — set_max_mesh_objective","text":"effective mesh size (MESH) measure landscape fragmentation based probability two randomly chosen points located patch (Jaeger, 2000). Maximizing context restoration favours fewer larger patches.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_mesh_objective.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Set an objective to maximize effective mesh size — set_max_mesh_objective","text":"Jaeger, J. . G. (2000). Landscape division, splitting index, effective mesh size: New measures landscape fragmentation. Landscape Ecology, 15(2), 115‑130. https://doi.org/10.1023/:1008129329289","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_mesh_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set an objective to maximize effective mesh size — set_max_mesh_objective","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  locked_out_data <- rast(  system.file(\"extdata\", \"locked_out.tif\", package = \"restoptr\") )  # plot data plot(rast(list(habitat_data, locked_out_data)), nc = 2)   # create problem with locked out constraints p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_max_mesh_objective() %>%   add_restorable_constraint(     min_restore = 5,     max_restore = 5,   ) %>%   add_locked_out_constraint(data = locked_out_data) %>%   add_settings(time_limit = 1)  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            Maximize effective mesh size  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 5, max_restore = 5, min_proportion = 1, unit = ha)  #>   -  locked out (data = in memory)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # solve problem s <- solve(p) #> Note: The current solution is the best that the solver could find within the time limit. However, the solver had not enough to prove whether it is optimal or not. Consider increasing the time limit if you need a better solution (solving time = 1 s)  # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_nb_pus_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Set an objective to maximize the number of planning units — set_max_nb_pus_objective","title":"Set an objective to maximize the number of planning units — set_max_nb_pus_objective","text":"Specify restoration problem (restopt_problem()) maximize number planning units.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_nb_pus_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set an objective to maximize the number of planning units — set_max_nb_pus_objective","text":"","code":"set_max_nb_pus_objective(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_nb_pus_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set an objective to maximize the number of planning units — set_max_nb_pus_objective","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_nb_pus_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set an objective to maximize the number of planning units — set_max_nb_pus_objective","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_nb_pus_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set an objective to maximize the number of planning units — set_max_nb_pus_objective","text":"Planning units correspond aggregated cells original dataset. Maximizing number planning units increased spatial extent restoration area. can useful budget limited aim restore larget possible extent.","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_nb_pus_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set an objective to maximize the number of planning units — set_max_nb_pus_objective","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  locked_out_data <- rast(  system.file(\"extdata\", \"locked_out.tif\", package = \"restoptr\") )  # plot data plot(rast(list(habitat_data, locked_out_data)), nc = 2)   # create problem with locked out constraints p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_max_nb_pus_objective() %>%   add_restorable_constraint(     min_restore = 5,     max_restore = 5,   ) %>%   add_locked_out_constraint(data = locked_out_data) %>%   add_settings(time_limit = 1)  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            Maximize number of planning units  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 5, max_restore = 5, min_proportion = 1, unit = ha)  #>   -  locked out (data = in memory)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # solve problem s <- solve(p) #> Good news: the solver found 1 solution statisfying the constraints that was proven optimal ! (solving time = 0.05 s)  # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_restore_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Set an objective to maximize the amount restoration area. — set_max_restore_objective","title":"Set an objective to maximize the amount restoration area. — set_max_restore_objective","text":"Specify restoration problem (restopt_problem()) maximize restoration area needed reach habitat proportion threshold specified problem description.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_restore_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set an objective to maximize the amount restoration area. — set_max_restore_objective","text":"","code":"set_max_restore_objective(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_restore_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set an objective to maximize the amount restoration area. — set_max_restore_objective","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_restore_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set an objective to maximize the amount restoration area. — set_max_restore_objective","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_restore_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set an objective to maximize the amount restoration area. — set_max_restore_objective","text":"restoration area corresponds minimum amount area must restored selected planning units reach minimum habitat proportion threshold specified problem description,","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_max_restore_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set an objective to maximize the amount restoration area. — set_max_restore_objective","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  locked_out_data <- rast(  system.file(\"extdata\", \"locked_out.tif\", package = \"restoptr\") )  # plot data plot(rast(list(habitat_data, locked_out_data)), nc = 2)   # create problem with locked out constraints p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_max_restore_objective() %>%   add_restorable_constraint(     min_restore = 5,     max_restore = 5,   ) %>%   add_locked_out_constraint(data = locked_out_data) %>%   add_settings(time_limit = 1)  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            Maximize restoration area  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 5, max_restore = 5, min_proportion = 1, unit = ha)  #>   -  locked out (data = in memory)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # solve problem s <- solve(p) #> Good news: the solver found 1 solution statisfying the constraints that was proven optimal ! (solving time = 0 s)  # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_nb_pus_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Set an objective to minimize the number of planning units — set_min_nb_pus_objective","title":"Set an objective to minimize the number of planning units — set_min_nb_pus_objective","text":"Specify restoration problem (restopt_problem()) minimize number planning units.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_nb_pus_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set an objective to minimize the number of planning units — set_min_nb_pus_objective","text":"","code":"set_min_nb_pus_objective(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_nb_pus_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set an objective to minimize the number of planning units — set_min_nb_pus_objective","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_nb_pus_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set an objective to minimize the number of planning units — set_min_nb_pus_objective","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_nb_pus_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set an objective to minimize the number of planning units — set_min_nb_pus_objective","text":"Planning units correspond aggregated cells original dataset. Minimizing number planning units reduces spatial extent restoration area.","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_nb_pus_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set an objective to minimize the number of planning units — set_min_nb_pus_objective","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  locked_out_data <- rast(  system.file(\"extdata\", \"locked_out.tif\", package = \"restoptr\") )  # plot data plot(rast(list(habitat_data, locked_out_data)), nc = 2)   # create problem with locked out constraints p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_min_nb_pus_objective() %>%   add_restorable_constraint(     min_restore = 5,     max_restore = 5,   ) %>%   add_locked_out_constraint(data = locked_out_data) %>%   add_settings(time_limit = 1)  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            Minimize number of planning units  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 5, max_restore = 5, min_proportion = 1, unit = ha)  #>   -  locked out (data = in memory)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # solve problem s <- solve(p) #> Good news: the solver found 1 solution statisfying the constraints that was proven optimal ! (solving time = 0.03 s)  # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_restore_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Set an objective to minimize the amount restoration area. — set_min_restore_objective","title":"Set an objective to minimize the amount restoration area. — set_min_restore_objective","text":"Specify restoration problem (restopt_problem()) minimize restoration area needed reach habitat proportion threshold specified problem description.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_restore_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set an objective to minimize the amount restoration area. — set_min_restore_objective","text":"","code":"set_min_restore_objective(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_restore_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set an objective to minimize the amount restoration area. — set_min_restore_objective","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_restore_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set an objective to minimize the amount restoration area. — set_min_restore_objective","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_restore_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Set an objective to minimize the amount restoration area. — set_min_restore_objective","text":"restoration area corresponds minimum amount area must restored selected planning units reach minimum habitat proportion threshold specified problem description,","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_min_restore_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Set an objective to minimize the amount restoration area. — set_min_restore_objective","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  locked_out_data <- rast(  system.file(\"extdata\", \"locked_out.tif\", package = \"restoptr\") )  # plot data plot(rast(list(habitat_data, locked_out_data)), nc = 2)   # create problem with locked out constraints p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_min_restore_objective() %>%   add_restorable_constraint(     min_restore = 5,     max_restore = 5,   ) %>%   add_locked_out_constraint(data = locked_out_data) %>%   add_settings(time_limit = 1)  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            Minimize restoration area  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 5, max_restore = 5, min_proportion = 1, unit = ha)  #>   -  locked out (data = in memory)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # solve problem s <- solve(p) #> Good news: the solver found 1 solution statisfying the constraints that was proven optimal ! (solving time = 0 s)  # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_no_objective.html","id":null,"dir":"Reference","previous_headings":"","what":"Configure the solver to only satisfy the constraints, without optimization\nobjective — set_no_objective","title":"Configure the solver to only satisfy the constraints, without optimization\nobjective — set_no_objective","text":"Specify restoration problem (restopt_problem()) satisfy constraints without optimization objective.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_no_objective.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configure the solver to only satisfy the constraints, without optimization\nobjective — set_no_objective","text":"","code":"set_no_objective(problem)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_no_objective.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configure the solver to only satisfy the constraints, without optimization\nobjective — set_no_objective","text":"problem restopt_problem() Restoration problem object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_no_objective.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Configure the solver to only satisfy the constraints, without optimization\nobjective — set_no_objective","text":"updated restoration problem (restopt_problem()) object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_no_objective.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Configure the solver to only satisfy the constraints, without optimization\nobjective — set_no_objective","text":"Using set_no_objective() restopt problem, solver return first solution found satisfying constraint, without optimization objective. \"objective\" setting set default creating restopt problem.","code":""},{"path":[]},{"path":"https://dimitri-justeau.github.io/restoptr/reference/set_no_objective.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Configure the solver to only satisfy the constraints, without optimization\nobjective — set_no_objective","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  # create problem p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>% set_no_objective()  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            No optimization objective  #> -----------------------------------------------------------------  #> constraints:         none defined  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 0 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # Solve problem s <- solve(p) #> Good news: the solver found 1 solution satisfying the constraints ! (solving time = 0.1 s) # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/solve.RestoptProblem.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve a restoration optimization problem — solve.RestoptProblem","title":"Solve a restoration optimization problem — solve.RestoptProblem","text":"Solve restoration optimization problem generate solution.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/solve.RestoptProblem.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve a restoration optimization problem — solve.RestoptProblem","text":"","code":"# S3 method for RestoptProblem solve(a, b, ...)"},{"path":"https://dimitri-justeau.github.io/restoptr/reference/solve.RestoptProblem.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve a restoration optimization problem — solve.RestoptProblem","text":"restopt_problem() Restoration problem object. b Argument used. ... Additional arguments: verbose: TRUE, output solver logs. (FALSE default)","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/solve.RestoptProblem.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve a restoration optimization problem — solve.RestoptProblem","text":"restopt_solution() object.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/solve.RestoptProblem.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve a restoration optimization problem — solve.RestoptProblem","text":"function relies Choco-solver (https://choco-solver.org/) solve restoration optimization problem. solver finds solution, outputs raster 5 possible values: NA : NA (NO_DATA) areas input habitat raster. 0 : non-habitat areas locked . 1 : non-habitat areas available selection. 2 : habitat areas. 3 : selected planning units restoration. solve function return -solution error, either solver find solution within time limit set (see add_settings), solver detected possible satisfy constraints (constraints contradictory). first case, can try increase time limit. second case, modify targets.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/reference/solve.RestoptProblem.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve a restoration optimization problem — solve.RestoptProblem","text":"","code":"# \\donttest{ # load data habitat_data <- rast(   system.file(\"extdata\", \"habitat_hi_res.tif\", package = \"restoptr\") )  available <- vect(   system.file(\"extdata\", \"accessible_areas.gpkg\", package = \"restoptr\") )  # create problem with locked out constraints p <- restopt_problem(     existing_habitat = habitat_data,     aggregation_factor = 16,     habitat_threshold = 0.7   ) %>%   set_max_mesh_objective() %>%   add_restorable_constraint(     min_restore = 5,     max_restore = 5,   ) %>%   add_available_areas_constraint(available) %>%   add_settings(time_limit = 1)  # print problem print(p) #> -----------------------------------------------------------------  #>                          Restopt                           #> -----------------------------------------------------------------  #> original habitat:     habitat_hi_res.tif  #> aggregation factor:   16  #> habitat threshold:    0.7  #> existing habitat:     in memory  #> restorable habitat:   in memory  #> -----------------------------------------------------------------  #> objective:            Maximize effective mesh size  #> -----------------------------------------------------------------  #> constraints:           #>   -  restorable (min_restore = 5, max_restore = 5, min_proportion = 1, unit = ha)  #>   -  locked out (data = in memory)  #> -----------------------------------------------------------------  #> settings:  #>   - precision = 4 #>   - time_limit = 1 #>   - nb_solutions = 1 #>   - optimality_gap = 0 #>   - solution_name_prefix = Solution   #> -----------------------------------------------------------------   # solve problem s <- solve(p) #> Note: The current solution is the best that the solver could find within the time limit. However, the solver had not enough to prove whether it is optimal or not. Consider increasing the time limit if you need a better solution (solving time = 1 s)  # plot solution plot(s)  # }"},{"path":"https://dimitri-justeau.github.io/restoptr/news/index.html","id":"restoptr-105","dir":"Changelog","previous_headings":"","what":"restoptr 1.0.5","title":"restoptr 1.0.5","text":"CRAN release: 2023-03-16 Fix issue related wrong argument name terra::compareGeom (https://github.com/dimitri-justeau/restoptr/issues/55) Fix CITATION file according CRAN comments","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/news/index.html","id":"restoptr-104","dir":"Changelog","previous_headings":"","what":"restoptr 1.0.4","title":"restoptr 1.0.4","text":"CRAN release: 2023-01-30 Remove dependency rgdal (see https://r-spatial.org/r/2022/04/12/evolution.html) Increase time limit tests, sometimes CRAN test servers complete tests due insufficient time.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/news/index.html","id":"restoptr-103","dir":"Changelog","previous_headings":"","what":"restoptr 1.0.3","title":"restoptr 1.0.3","text":"CRAN release: 2022-11-12 Fix unexpected behaviour add_available_areas_constraint data vector data. Add touches option add_available_areas_constraint add_locked_out_constraint, useful data vector data. Fix Warning due terra update using levels. Add solution_name_prefix setting, allows defining custom prefix solutions names. Fix restoptr.Rmd vignette, bug due new terra version, allowing subset layers unique name. fixed using newly introduced solution_name_prefix setting. Allow numeric values min_restore max_restore, add_restorable_constraint() unit cells, conversion integer done conversion unitless values. Relies restopt-2.0.1, brings improved performances compactness constraint.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/news/index.html","id":"restoptr-102","dir":"Changelog","previous_headings":"","what":"restoptr 1.0.2","title":"restoptr 1.0.2","text":"CRAN release: 2022-10-13 Fix bugs. Add vignette illustrate submitted article case study.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/news/index.html","id":"restoptr-101","dir":"Changelog","previous_headings":"","what":"restoptr 1.0.1","title":"restoptr 1.0.1","text":"CRAN release: 2022-06-17 Update doc fix minor issue r-oldrel-windows-ix86+x86_64 Remove time limit tests pass CRAN tests","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/news/index.html","id":"restoptr-100","dir":"Changelog","previous_headings":"","what":"restoptr 1.0.0","title":"restoptr 1.0.0","text":"CRAN release: 2022-06-09 First stable release package.","code":""},{"path":"https://dimitri-justeau.github.io/restoptr/news/index.html","id":"restoptr-00099999","dir":"Changelog","previous_headings":"","what":"restoptr 0.0.0.99999","title":"restoptr 0.0.0.99999","text":"Initial work developing package.","code":""}]
